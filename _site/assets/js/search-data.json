{"0": {
    "doc": "Creando proyecto con CLI",
    "title": "Creando proyecto con CLI",
    "content": "# Creando un proyecto usando CLI y framework UI Comenzaremos creando un proyecto a través de la línea de comandos de Vue. Para ello la instalaremos con el siguiente comando ```bash npm install -g @vue/cli ``` Una vez instalado navegamos a través de la terminal hacia el directorio donde queremos crear el proyecto y ejecutamos el siguiente comando: ```bash vue create ``` Deberemos contestar una serie de preguntas. Veamos en detalle que responderemos a cada una de ellas. 1) Seleccionaremos la opción que nos permita seleccionar manualmente las tecnologías que usaremos ![Imagen de paso 1 de instalación](images/01-vue-cli-install-01.png?raw=true) 2) Utilizando la tecla `espacio` agregaremos las opciones que puedes ver en la siguiente imagen ![Imagen de paso 2 de instalación](images/01-vue-cli-install-02.png?raw=true) 3) Elegiremos la versión 2 de Vue ![Imagen de paso 3 de instalación](images/01-vue-cli-install-03.png?raw=true) 4) Seleccionar `Y` para configurar History mode y posteriormente haremos la configuración requerida para el servidor en Express. Más detalles en [este link](https://router.vuejs.org/guide/essentials/history-mode.html#html5-history-mode) ![Imagen de paso 4 de instalación](images/01-vue-cli-install-04.png?raw=true) 5) Utilizaremos la configuración de Javascript estándar para la herramienta [ESLint](https://eslint.org/). Si quieres conocer más detalles sobre este estándar puedes visitar [este link](https://standardjs.com/) ![Imagen de paso 5 de instalación](images/01-vue-cli-install-05.png?raw=true) 6) Seleciona lint on save ![Lint on save](images/01-vue-cli-install-05-b.png?raw=true) 7) Utilizaremos [Jest](https://jestjs.io/) para crear pruebas de integración en el proyecto. ![Imagen de paso 6 de instalación](images/01-vue-cli-install-06.png?raw=true) 8) Utilizaremos [Cypress](https://www.cypress.io/) para crear pruebas e2e. ![Imagen de paso 7 de instalación](images/01-vue-cli-install-07.png?raw=true) 9) Seleccionaremos la opción que nos permite que las configuraciones de las herramientas de desarrollo como `ESLint` tenga su propio archivo de configuración ![Imagen de paso 8 de instalación](images/01-vue-cli-install-08.png?raw=true) 10) Finalmente damos enter para utilizar la opción por defecto (por convención es la opción en mayúsculas) ![Imagen de paso 9 de instalación](images/01-vue-cli-install-09.png?raw=true) Esto creará una carpeta con la estructura inicial y todo lo necesario para construir nuestra aplicación Frontend. Una vez terminada la instalación ingresamos al repositorio recién creado y agregaremos [Vuetify](https://vuetifyjs.com/) (durante el proceso de instalación vue-cli ejecutó `git init`) utilizando el siguiente comando: ```bash vue add vuetify ``` Vuetify es una de las tantas (Buefy, Element, Bootstrap Vue) librerías de componentes UI de alta productividad para Vue. Nos preguntará si queremos seleccionar algún tipo de configuración. Seleccionaremos la opción predeterminada como muestra la siguiente imagen: ![Imagen de paso 10 de instalación](images/01-vue-cli-install-10.png?raw=true) Ya hemos instalado todo lo necesario para comenzar nuestro proyecto Frontend. Al correr el comando `npm run serve` y luego yendo al navegador en la dirección `http://localhost:8080/` veremos lo siguiente: ![Imagen resultado final de instalaciones](images/01-vue-cli-install-11.png?raw=true) Para finalizar agregaremos los cambios sumados por Vuetify a Git. Para esto comenzeremos a utilizar el formato de [Conventional Commits](https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional) para escribir los mensajes de commit. Escribamos el siguiente comando: ```bash git add . git commit -m \"chore(vuetify): Create Vue project with Vuetify\" ``` Listo! ya estamos preparados para ir al siguiente paso de la construcción del proyecto . | ⬅️ Volver al Índice del curso | Escribiendo Pruebas E2E siguiendo la metodología BDD ➡️ | . ",
    "url": "/docs/01-vue-cli-install.html",
    "relUrl": "/docs/01-vue-cli-install.html"
  },"1": {
    "doc": "Historias de usuario y BDD",
    "title": "Ingreso",
    "content": "Registro Ingresar ``` y ahora actualizamos el archivo `src/router/index.js` con lo siguiente: ```javascript import Vue from 'vue' import VueRouter from 'vue-router' import Login from '../views/Login.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'Login', component: Login } ] const router = new VueRouter({ mode: 'history', routes }) export default router ``` Ahora recargamos las pruebas y deberíamos ver nuestras pruebas pasando y la interfaz más acorde al objetivo de negocio que estamos desarrollando mediante pruebas. El resultado sería similar a la siguiente imagen: ![Imagen que muestra el navegador que corre cypress con las pruebas pasando](images/02-bdd-with-cypress-05.png) #### Integrando el servicio de autenticación de Firebase Dado el contexto de nuestra aplicación, lo que haremos será enviar invitaciones manualmente a quienes publicarán productos para trueques y darles un usuario y contraseña de acceso que manejaremos directamente desde la interfaz de Firebase. Si ya tienes cuenta de Google, puedes autenticarte y dirigirte a [https://console.firebase.google.com/](https://console.firebase.google.com/), donde veremos una pantalla como la siguiente: ![Imagen que muestra la interfaz de firebase para crear un proyecto](images/02-bdd-with-cypress-06.png) Una vez dentro del admin de Firebase creamos un proyecto. Después de agregar el nombre nos pregunta si queremos incluir Analytics. Deshabilitar esta opción como en la siguiente imágen: ![Deshabilitar Analytics](images/02-bdd-with-cypress-06-b.png). Después se puede activar si se requiere. Cuando indique que el proyecto ha sido creado damos click en `continuar`. Posteriormente presionamos el botón indicado en la imagen para registrar nuestra aplicación de tipo Web: ![Imagen que muestra la interfaz de firebase para registrar una aplicación](images/02-bdd-with-cypress-07.png) Cuando lo presionemos nos dirá que le demos un nombre a nuestra aplicación y luego aparecerá lo siguiente: ![Imagen que muestra la interfaz de firebase para obtener los datos de acceso](images/02-bdd-with-cypress-08.png) Seleccionaremos lo que está remarcado en la imagen y lo llevaremos a un nuevo archivo que crearemos en el directorio `src`. Primero vamos a crear el directorio en `src/firebase` y al interior de ese directorio crearemos 2 archivos llamados `config.js` e `index.js`. ``` ... └─── public └─── src ... └─── firebase config.js index.js ... ``` el contenido de ambos archivos será el siguiente: **config.js** Los datos de este archivo los copiaremos de lo indicado en la imagen anterior. ```javascript export default { apiKey: '' authDomain: '' projectId: '' storageBucket: '' messagingSenderId: '' appId: '', } ``` **index.js** ```javascript import firebase from 'firebase/app' import 'firebase/auth' import config from './config' const firebaseApp = firebase.initializeApp(config) const Auth = firebaseApp.auth() export { Auth } ``` Ahora debemos instalar `firebase` en el proyecto. Para ello ejecutamos el siguiente comando en una terminal aparte para mantener corriendo Cypress: ```bash npm install firebase ``` Con esto nuestro proyecto quedará preparado para conectarnos a Firebase llegado el momento. Ahora volvemos a la interfaz de Firebase donde nos quedamos anteriormente y presionamos el botón `Ir a la consola`: ![Imagen que muestra la interfaz de firebase para obtener los datos de acceso](images/02-bdd-with-cypress-09.png) Finalmente habilitaremos la autenticación a través de correo electrónico/contraseña desde la consola de Firebase siguiendo estos pasos: Presionamos desde el panel de control la opción `Authentication` como muestra la siguiente imagen: ![Imagen que muestra la interfaz de firebase para configurar la autenticación](images/02-bdd-with-cypress-10.png) Nos llevará a otra pantalla donde debemos presionar `Comenzar` y eso hará aparecer todas las opciones disponibles para la autenticación. Por defecto todos los tipos de autenticación vienen desactivados. Para habilitar la autenticación con correo electrónico/Contraseña y presionamos el botón editar donde se indica: ![Imagen que muestra la interfaz de firebase para configurar la autenticación de correo electrónico/contraseña](images/02-bdd-with-cypress-11.png) Y finalmente habilitamos este servicio y presionamos \"Guardar\". Notar que mantenemos desactivada la opción `Vínculo del correo electrónico (acceso sin contraseña) ![Imagen que muestra la interfaz de firebase para configurar la autenticación de correo electrónico/contraseña](images/02-bdd-with-cypress-12.png) Ahora crearemos un usuario presionando el tab `Users` tal como se indica en la siguiente imagen: ![Imagen que muestra la interfaz de firebase para configurar la autenticación de correo electrónico/contraseña](images/02-bdd-with-cypress-13.png) Presionamos el Botón `Agregar usuario` y crearemos un usuario con el siguiente perfil: ``` Correo electrónico: test-e2e@boolean.cl Contraseña: booleanacademia ``` ![Imagen que muestra la interfaz de firebase para configurar la autenticación de correo electrónico/contraseña](images/02-bdd-with-cypress-14.png) Si quieres puede elegir otro correo electrónico y contraseña y reemplazarlo donde corresponda. Indicamos que este usuario, a pesar de estár en entorno productivo, será solamente para realizar pruebas. #### Un nuevo escenario en la historia de usuario para realizar una autenticación exitosa Ahora trabajaremos el caso (escenario en historias de usuario) exitóso de la autenticación. La historia sería como sigue: ```ruby Funcionalidad: login de la aplicación ... Escenario: login con credenciales válidas Como un usuario no registrado Cuando ingreso a la aplicación Y completo el campo username con 'test-e2e@boolean.cl' Y el campo password con 'booleanacademia' Entonces debería ver la página de productos ``` Escribiremos una nueva prueba de software basada en la historia de usuario que consistirá en autenticarse en Firebase con los datos de prueba y validar que la aplicación nos lleve a la página `/productos`. Vamos a editar el archivo `tests/e2e/specs/login.js` y reemplazar su contenido por lo siguiente: ```javascript describe('login test suite', () => { it('does not work with wrong credentials', () => { cy.visit('/') cy.get('[data-cy=\"username\"]').type('info') cy.get('[data-cy=\"password\"]').type('visitor') cy.get('[data-cy=\"login-btn\"]').click() cy.location('pathname').should('equal', '/') }) it('does work with valid credentials', () => { cy.visit('/') cy.get('[data-cy=\"username\"]').type('test-e2e@boolean.cl') cy.get('[data-cy=\"password\"]').type('booleanacademia') cy.get('[data-cy=\"login-btn\"]').click() cy.location('pathname').should('equal', '/productos') }) }) ``` Ahora recargamos Cypress y veremos el siguiente error: ![Imagen que muestra el error de Cypress cuando agregamos una nueva prueba](images/02-bdd-with-cypress-15.png) Ahora vamos a escribir el código más simple que sea capaz de dejar pasando esta prueba. Vamos al archivo `src/views/Login.vue` y agregamos el siguiente contenido al metodo `login()` ```javascript ... methods: { login () { this.$router.push({ name: 'Products' }) } } ... ``` Luego vamos a crear un nuevo archivo en `src/views` llamado `Products.vue` con el siguiente contenido: ```html ",
    "url": "/docs/02-bdd-with-cypress.html",
    "relUrl": "/docs/02-bdd-with-cypress.html"
  },"2": {
    "doc": "Historias de usuario y BDD",
    "title": "Productos",
    "content": "``` Luego vamos al archivo `src/router/index.js` y reemplazamos su contenido por el siguiente: ```javascript import Vue from 'vue' import VueRouter from 'vue-router' import Login from '../views/Login.vue' import Products from '../views/Products.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'Login', component: Login }, { path: '/productos', name: 'Products', component: Products } ] const router = new VueRouter({ mode: 'history', routes }) export default router ``` Al recargar vemos que la nueva prueba si está pasando pero estos cambios provocaron que se cayera la prueba anterior: ![Imagen que muestra el error de Cypress cuando agregamos una nueva prueba](images/02-bdd-with-cypress-16.png) Excelente! esto es lo que debería pasar en un flujo de trabajo guiado por pruebas de software: Los cambios ejecutados en el código eventualmente podrían afectar a otras pruebas por lo que es nuestro deber que el mínimo código que agregamos para pasar una prueba sea capaz de mantener todas las otras pruebas pasando y no sólo la que acabamos de escribir. Para solucionar esto usaremos la `refs` que hemos asociado al elemento `v-form` para crear una función que valide si el formulario está correcto. A través de la `refs` obtendremos la instancia del elemento `v-form` y podremos utilizar su API para usar el método `validate`. Si quieres ver más detalle sobre la API de este elemento puedes visitar el [siguiente enlance](https://vuetifyjs.com/en/api/v-form/#functions-validate) Iremos a modificar el archivo `src/views/Login.vue` y agregamos lo siguiente en la sección `methods` ```javascript ... methods: { validate () { return this.$refs.form.validate() }, login () { if (this.validate()) { this.$router.push({ name: 'Products' }) } } } ... ``` y al recargar las pruebas podemos ver como ambas están pasando. Excelente trabajo! Tip: Revisa la consola por errores de identación que puedan entorpecer la \"compilación\" Ahora debemos hacer una refactorización para lograr una conexión real con el servicio de Firebase. Lo que haremos será modificar la sección ` ``` Podemos notar como es que importamos el código de firebase que agregamos al comienzo de este capítulo. La función que efectúa la integración del logín es `signInWithEmailAndPassword` que puedes ver en la misma [documentación](https://firebase.google.com/docs/auth/web/password-auth#sign_in_a_user_with_an_email_address_and_password). Ahora al recargar las pruebas estas deberían seguir funcionando. ![Imagen que muestra las 2 pruebas pasando](images/02-bdd-with-cypress-17.png) #### Página de productos Continuamos con con la siguiente historia de usuario. Esta vez con la vista de los productos. ```ruby Funcionalidad: página de productos Escenario: Listado simple Como un usuario que inició sesión en la aplicación Cuando ingreso a la página de productos Entonces debería ver una lista de productos ``` Ahora escribiremos una prueba basada en la historia. Para esto crearemos un nuevo archivo en el directorio `tests/e2e/specs` y lo llamaremos `products.js`. Ahora agregaremos el siguiente contenido: ```javascript describe('products test suite', () => { it('shows a list of products',() => { cy.visit('/') cy.get('[data-cy=username]').type('test-e2e@boolean.cl') cy.get('[data-cy=password]').type('booleanacademia') cy.get('[data-cy=login-btn]').click() cy.fixture('products.json') .then((products)=>{ cy.get('[data-cy=\"products\"] li').should('have.length', products.length) }); }) }) ``` Si ejecutamos esta prueba veremos que falla por los fixtures, pero nos encargaremos de eso más adelante. En esta prueba vemos que es la tercera vez que escribimos las instrucciones para realizar una autenticación. Por suerte Cypress permite agrupar comandos comunes en funciones que podemos centralizar y reutilizar. Para lograr esto iremos al archivo `tests/e2e/support/commands.js` y descomentaremos la linea indicada en la siguiente imagen: ![Imagen que muestra el comando de cypress a descomentar](images/02-bdd-with-cypress-18.png) y los reemplazaremos por lo siguiente: ```javascript Cypress.Commands.add(\"login\", (email, password) => { cy.visit('/') cy.get('[data-cy=username]').type(email) cy.get('[data-cy=password]').type(password) cy.get('[data-cy=login-btn]').click() }) ``` y luego iremos a editar los archivos en el directorio `tests/e2e/specs` y reemplazaremos cada uno con el código correspondiente: **login.js** ```javascript describe('login test suite', () => { it('does not work with wrong credentials', () => { cy.login('info', 'visitor') cy.location('pathname').should('equal', '/') }) it('does work with valid credentials', () => { cy.login('test-e2e@boolean.cl', 'booleanacademia') cy.location('pathname').should('equal', '/productos') }) }); ``` **products.js** ```javascript describe('products test suite', () => { it('shows a list of products',() => { cy.login('test-e2e@boolean.cl', 'booleanacademia') cy.fixture('products.json') .then((products)=>{ cy.get('[data-cy=\"product-item\"]').should('have.length', products.length) }) }) }) ``` Ahora cerraremos la ventana del navegador para volver al menu principal de Cypress en el cuál veremos incluido el nuevo archivo. Ahora presionamos el botón que dice `Run all specs` que debería lucir como la siguiente imagen: ![Imagen que muestra el menu principal de Cypress](images/02-bdd-with-cypress-19.png) Y veremos el siguiente error: ![Imagen que muestra el menu principal de Cypress](images/02-bdd-with-cypress-20.png) #### ¿Qué son los Fixtures ? El error de la anterior prueba es porque aún no creamos el archivo `products.json`. Al revisar más en detalle podemos revisar que el siguiente código es el que causa el problema ```javascript cy.fixture('products.json') .then((products)=>{ cy.get('[data-cy=product-item]').should('have.length', products.length) }) ``` ¿Para que agregamos este código? Un `Fixture` es información estática que permite que las pruebas de software sean repetibles en el tiempo. En otras palabras es un estado fijo que se le carga a las pruebas a través de los fixtures. En nuestro caso asumiremos la existencia de un archivo `products.json` que contendrá esta información. Este simple archivo estático cobra relevancia por que sirve de punto de encuentro entre las personas de negocio y los desarrolladores Backend y Frontend. Si vamos al archivo `tests/e2e/plugins/index.js` veremos entre otras configuraciones una en particular que dice lo siguiente: ```javascript fixturesFolder: 'tests/e2e/fixtures', ``` En esta linea de código se define desde donde Cypress va a leer los archivos Fixture. Lo haremos será crear una carpeta llamada `fixtures ` en `tests/e2e` tal como lo indica la línea de código que estamos analizando. dentro de esta nueva carpeta agregaremos un archivo llamado `products.json` con el siguiente contenido: **products.json** ```json [ { \"id\": 1, \"name\": \"Epiphone Explorer Gothic \", \"description\": \"Guitarra color negro\", \"image\": \"https://images.unsplash.com/photo-1550985616-10810253b84d?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=742&q=80\", \"code\": \"0001\" }, { \"id\": 2, \"name\": \"Cordoba Mini Bass\", \"description\": \"Bajo pequeño tipo ukelele. Excelente sonido de bajo.\", \"image\": \"https://images.unsplash.com/photo-1556449895-a33c9dba33dd?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=2734&q=80\", \"code\": \"0002\" }, { \"id\": 3, \"name\": \"Distorsión Custom Badass 78\", \"description\": \"Peda del guitarra de distorsión.\", \"image\": \"https://images.unsplash.com/photo-1527865118650-b28bc059d09a?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=668&q=80\", \"code\": \"0003\" }, { \"id\": 4, \"name\": \"Distorsión TMiranda Bass Drive BD-1\", \"description\": \"Pedal del bajo de distorsión.\", \"image\": \"https://images.unsplash.com/photo-1614963590047-0b8b9daa3eb7?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=2089&q=80\", \"code\": \"0004\" }, { \"id\": 5, \"name\": \"Looper Hotone Wally\", \"description\": \"Pedal de looper. Super portable.\", \"image\": \"https://images.unsplash.com/photo-1595167151695-dfb4846e70f8?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=668&q=80\", \"code\": \"0005\" } ] ``` Ahora deberíamos obtener un nuevo error en Cypress, ya que la prueba esperaba encontrar cinco (5) elementos con el atributo `data-cy=product-item`, pero encuentra cero (0) como indica la siguiente imagen: ![Imagen que muestra error de cypress](images/02-bdd-with-cypress-20.png) Al igual que las veces anteriores escribiremos el código lo más simple posible para pasar esta prueba. Modificamos el archivo `src/views/Products.vue` y agregaremos lo siguiente en la sección ``: ```html ",
    "url": "/docs/02-bdd-with-cypress.html",
    "relUrl": "/docs/02-bdd-with-cypress.html"
  },"3": {
    "doc": "Historias de usuario y BDD",
    "title": "Productos",
    "content": "``` Guardamos, recargamos las pruebas en Cypress y vemos que todas la prueba está pasando: ![Imagen que muestra error de cypress](images/02-bdd-with-cypress-22.png) Para la refactorización nos basaremos en el ejemplo de Vuetify presentado en el siguiente [enlace](https://vuetifyjs.com/en/components/images/#grid). Modificamos completo el archivo `src/views/Products.vue` con el siguiente contenido: ```html ",
    "url": "/docs/02-bdd-with-cypress.html",
    "relUrl": "/docs/02-bdd-with-cypress.html"
  },"4": {
    "doc": "Historias de usuario y BDD",
    "title": "Productos",
    "content": "{{ product.name }} . {{ product.description }} . ``` Notarás que hicimos una copia del contenido del archivo `products.json` que agregamos como fixture anteriormente. Esto será de utilidad ya que ahora nuestra aplicación implementa \"el contrato\" JSON del archivo y esta mostrando los atributos en función de esta lista. Al recargar Cypress veremos que luego de hacer los cambios en el código nuestra prueba sigue pasando: ![Imagen que muestra cypress con las pruebas pasando](images/02-bdd-with-cypress-23.png) #### Agregando Axios y haciendo una petición al Servidor Ya hemos modelado y escrito las pruebas necesarias para que nuestra aplicación cuente con la funcionalidad básica que permita mostrar una lista de productos luego de una autenticación. Pero la última funcionalidad que escribimos muestra una lista estática de productos. Ha llegado el momento de realizar una consulta a un servidor que nos entregue la información de los productos acorde al contrato JSON que modelamos utilizando Fixtures. Sin dejar de correr Cypress, abriremos una nueva terminal en el proyecto e instalaremos la librerías `Axios` utilizando el siguiente comando: ```bash npm install axios ``` Si quieres conocer más sobre su documentación te recomendamos mirar [este enlace](https://github.com/axios/axios#axios-api). Ahora iremos al archivo `src/store` y reemplazaremos su contenido por lo siguiente: ```javascript import Vue from 'vue' import Vuex from 'vuex' import axios from 'axios' Vue.use(Vuex) export default new Vuex.Store({ state: { products: [] }, mutations: { SET_PRODUCTS (store, products) { store.products = products } }, actions: { async getProducts (actionContext) { const { commit } = actionContext const productsURL = '/api/products' try { const response = await axios.get(productsURL) commit('SET_PRODUCTS', response.data) } catch (error) { console.log(error.message) } } }, modules: { } }) ``` Con esto dejaremos lista una acción de `Vuex` que nos permitirá desde nuestro componente ejecutar la acción `getProducts` que agregará al estado de la aplicación los productos desde un servidor externo. El servidor deberá responder los productos basados en el contrato que consume nuestro componente `Products`. Ahora iremos al archivo `src/views/Login.vue` y editaremos la sección ` ``` Al recargar Cypress vamos a notar que las pruebas vuelven a fallar. ![Imagen que muestra error de cypress](images/02-bdd-with-cypress-24.png) Esto quiere decir que nuestro componente está tomando el valor por defecto desde el `store` y eso hace fallar las pruebas. Si quieres entender mejor los métodos como `created` que se ejecuta cuando el componente se inicializa en Vue puedes revisar el [siguiente enlace](https://v3.vuejs.org/api/options-lifecycle-hooks.html#created) Y si quieres conocer como el store de Vuex nos permite agregar acciones al componente para ejecutarlas cuando sea necesario puedes ver [este enlace](https://vuex.vuejs.org/guide/actions.html#dispatching-actions-in-components) Además en la imagen anterior vemos resaltado la petición al servidor que se hizo y que Cypress nos informa que ha recibido como respuesta un error de tipo `404` ``` (XHR) GET 404 /api/products ``` Esto es debido a que en nuestro componente realiza al inicializarse un llamado a la acción `getProducts` configurada en nuestro Store de Vuex. Esto lo podemos ver en el método `created()` del componente en `src/views/Products.vue` ```javascript methods: { ...mapActions([ 'getProducts' ]) }, created () { this.getProducts() } ``` Para que esta prueba pase necesitaremos un servidor que responda la petición a la url `http://localhost:8080/api/products`. ¿Como lograremos esto? Lo resolveremos en el siguiente capítulo. | ⬅️ Creando un proyecto usando CLI y framework UI | Reorganización del proyecto como un repositorio monolítico y agregar Backend ➡️ | . ",
    "url": "/docs/02-bdd-with-cypress.html",
    "relUrl": "/docs/02-bdd-with-cypress.html"
  },"5": {
    "doc": "Historias de usuario y BDD",
    "title": "Historias de usuario y BDD",
    "content": "# Implementando historias de usuario con BDD Comenzaremos a desarrollar siguiendo la metodología Behaviour Driven Design (abreviada como BDD). Si quieres conocer más en detalle acerca de ella te recomendamos ver [este video](https://www.youtube.com/watch?v=_bGtaCvaHLE&t=2959s). En resúmen se trata de una metodología para que personas no técnicas describan lo que esperan del software utilizando historias de usuario, las cuales describen las interacciones que hace un cierto tipo de usuario y el resultado esperado. Nuestra primera historia de usuario es la siguiente: ```ruby Funcionalidad: login de la aplicación Escenario: login con credenciales inválidas Como un usuario no registrado Cuando ingreso a la aplicación Y completo el campo username con 'info' Y el campo password con 'visitor' Entonces debería permanecer en la misma página ``` Como detallamos en el curso, estas historias de usuario se pueden transformar directamente en pruebas de aceptación utilizando conjuntamente la herramientas Cucumber y Cypress. Nosotros omitiremos este paso para enfocarnos en el desarrollo javascript y escribiremos directamente la historia de usuario utilizando la api de Cypress. Para esto vamos a modificar la prueba e2e por defecto generada durante el proceso de creación. En concreto el archivo de llama `test.js`. Te puedes guiar por el siguiente esquema del proyecto: ``` ... └─── public └─── src └─── tests └─── e2e └─── plugins └─── specs test.js { it('does not work with wrong credentials', () => { cy.visit('/') cy.get('[data-cy=username]').type('info') cy.get('[data-cy=password]').type('visitor') cy.get('[data-cy=login-btn]').click() cy.location('pathname').should('equal', '/') }) }) ``` #### ¿Que significa este código? Te preguntarás por qué utilizamos los atributo del tipo `data-cy=*` como selectores HTML en nuestra aplicación. Puedes ver el siguiente artículo desde el Blog oficial de Cypress en [este enlace](https://docs.cypress.io/guides/references/best-practices#Selecting-Elements). En resumen se trata de que las pruebas e2e sean independientes (no acopladas) a cambios en el diseño, resistente a los posibles cambios que podrían sufrir las tradicionales clases o ids. Por supuesto que como aún no hemos escrito código, esta prueba de software comenzará fallando y será nuestro deber escribir el mínimo código necesario para hacerla pasar. Una vez que la prueba de software esté pasando, debemos refactorizar el código (si aplica) y mantener la prueba pasando. A este ciclo se le conoce como `Red - Green - Refactor`. Para ver nuestra prueba fallando ejecutaremos el siguiente comando: ```shell npm run test:e2e ``` Veremos aparecer la siguiente ventana: ![Imagen que muestra el menú principal de cypress](images/02-bdd-with-cypress-01.png) Al hacer click sobre `login.js` aparecerá finalmente la prueba de software fallando como muestra la siguiente imagen: ![Imagen que muestra el navegador que corre cypress](images/02-bdd-with-cypress-02.png) Veremos una ventana del navegador en la cual al lado izquierdo están los pasos sucesivos que hemos escrito en la prueba de software y al lado derecho está nuestra aplicación. Si nos fijamos en el panel izquierdo hay 2 instrucciones: ``` 1 VISIT / 2 GET [data-cy=username] ``` La primera instrucción hizo que nuestra aplicación navegará a la ruta raíz sin problemas, pero luego la segunda instrucción intentó encontrar en el HTML un elemento con el atributo `data-cy=username`. Esto lo vemos traducido en el siguiente mensaje de error: ``` CypressError: Timed out retrying: Expected to find element: '[data-cy=username]', but never found it. ``` Si vamos a revisar el código podremos encontrar las 2 líneas que desencadenaron las acciones del panel izquierdo: ```javascript cy.visit('/') cy.get('[data-cy=username]').type('info') ``` podemos ver como es que el comando `cy.get` es el que se usa para encontrar elementos HTML y luego interactuar con ellos. #### ¿Cómo hacemos para pasar la prueba? Como mencionamos anteriormente la metodología dice que la prueba de software debe pasar escribiendo el menor código posible. En este caso basta con que agreguemos cualquier etiqueta HTML que tenga el atributo `[data-cy=username]`. Para esto nos vamos a dirigir al archivo `src/App.vue` y agregaremos lo siguiente en la sección HTML (``), donde esta definido el elemento `` ```html ..... ``` Una vez agregado esto, guardamos el archivo y veremos que la terminal dirá `COMPILING`. Esperaremos que esto salga OK y luego vamos nuevamente a Cypress y presionamos el botón para recargar las pruebas como se ve en al siguiente imagen ![Imagen que muestra el menú principal de cypress](images/02-bdd-with-cypress-03.png) Veremos como al lado derecho aparece el input que agregamos y con valor `info`. Esto gracias al comando `.type` que ejecutamos sobre el elemento seleccionado. Ahora veremos un nuevo mensaje de error: ``` CypressError: Timed out retrying: Expected to find element: '[data-cy=password]', but never found it. ``` Si hacemos un análisis de lo que está escrito en la prueba de software podemos deducir que necesitaremos otro input esta vez con el atributo `[data-cy=\"password\"]` y luego un botón con el atributo `data-cy=\"login-btn\"`. Al agregar esto en el archivo `views/App.vue` quedará así: ```html ... Ingresar ... ``` Finalmente al recargar las pruebas veremos como es que ahora se puso de color verde lo que indica que la prueba está pasando. ![Imagen que muestra el navegador que corre cypress con las pruebas pasando](images/02-bdd-with-cypress-04.png) #### Refactorización Si bien la prueba está pasando, vemos que la interfaz de usuario no cumple el objetivo. Los elementos están definidos sin estilo y aún tenemos todo el código que agregó Vuetify en su instalación. Modificaremos todo el código de la página inicial para que ahora sea un de Login utilizando Vuetify. Mantendremos corriendo Cypress mientras implementamos los cambios para que al terminar recarguemos las pruebas y nos aseguremos que siguen pasando. Lo primero será modificar el archivo `src/App.vue` y reemplazaremos todo su contenido por lo siguiente: ```html ``` Luego iremos al directorio `views`. Eliminamos el archivo `About.vue` y vamos a cambiar el nombre del archivo `Home.vue` por `Login.vue`. En cuanto guardemos esto veremos un error en la terminal pero lo solucionaremos de inmediato, cuando actualicemos el router. Ahora vamos al archivo `Login.vue` y reemplazaremos todo su contenido con lo siguiente: ```html ",
    "url": "/docs/02-bdd-with-cypress.html",
    "relUrl": "/docs/02-bdd-with-cypress.html"
  },"6": {
    "doc": "Fullstack Javascript",
    "title": "Fullstack Javascript",
    "content": "# Reorganización del proyecto como un repositorio monolítico y agregar Backend En función de la metodología que estamos utilizando (el mínimo código posible) lo que haremos será centralizar en este mismo repositorio todo lo necesario para que las pruebas pasen sin problema. En este caso las pruebas end-to-end requieren que desde el Frontend se realice una petición (request) hacia un backend que aún no existe. Este backend debe ser capaz de responder a una petición GET en la URL `/api/products`. Dado este panorama, lo que haremos será reorganizar el repositorio siguiendo algunos lineamientos: - Dividiremos el repositorio en 2 dominios: Frontend y Backend. Cada dominio resolverá una parte del problema. En este caso el Frontend será la aplicación Web que interactúa con el usuario y el Backend entrega la información gestionando una Base de datos. - Crearemos un directorio en la raíz para centralizar todos los Fixtures que le serán útiles tanto al dominio de Backend como Frontend. - Cuando ambos dominios de negocio estén listos para salir a producción configuraremos procedimientos automáticos de calidad que validen la sintáxis en todo el monorepo y que ejecuten las antes de que se suban cambios al repositorio remoto. Cancelamos la ejecución de Cypress (cmd+C o ctrl+C) y movemos todos los archivos y carpetas hacia `/frontend`, excepto el archivo .gitignore que permanece en la raíz, dejando el repositorio como indica el siguiente esquema: ``` └─── backend └─── frontend └─── fixtures products.json └─── backend └─── src └─── frontend └─── node_modules └─── public └─── src └─── tests .browserslistrc .editorconfig .eslintrc.js babel.config.js cypress.json jest.config.js package-lock.json package.json README.md vue.config.js .gitignore ``` La implementación de las validaciones automatizadas de linter y pruebas las dejaremos para más adelante, cuando ya tengamos listos los proyectos de Frontend y Backend. Continuamos con el Backend. Lo primero que haremos será entrar al directorio `backend` desde la terminal y ejecutaremos lo siguiente: ```bash npm init -f npm i express npm i --save-dev nodemon ``` Ahora creamos un nuevo archivo en `backend/src` llamado `server.js` con el siguiente contenido: **backend/src/server.js** ```javascript const express = require('express') const app = express() const port = 3000 app.use('/api/products', (request, response) => { const statusCode = 200 console.log(`GET with status code ${statusCode} in /api/products endpoint`); return response .status(statusCode) .json([]) }) app.listen(port, () => { console.log(`App server listening on port ${port}`); }) ``` Una vez ejecutado esto deberíamos ver el directorio `backend` de la siguiente forma ``` └─ backend └─ node_modules └─ src server.js package-lock.json package.json ``` Modificamos el `backend/package.json` y quedará de la siguiente forma: ```json { \"name\": \"backend\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"nodemon src/server.js\", \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"express\": \"^4.17.1\" }, \"devDependencies\": { \"nodemon\": \"^2.0.7\" } } ``` Con esto ya podremos levantar el servidor preocupándonos de estar dentro del directorio `backend` ejecutamos: ```bash npm run dev ``` Veremos que nuestro servidor ya está corriendo como en la siguiente imagen: ![Imagen de servidor node con express corriendo en la terminal](images/03-monorepo-backend-01.png) Ahora abriremos otra ventana de la terminal y nos dirigimos al directorio `frontend`. Una vez dentro ejecutamos nuevamente el comando para abrir Cypress y nuestra aplicación: ```bash npm run test:e2e ``` Una vez veamos la interfaz de Cypress, presionamos el botón `run all specs` y veremos el siguiente error: ![Imagen de cypress fallando](images/03-monorepo-backend-02.png) Esto es debido a que en los pasos anteriores movimos la carpeta `fixtures` desde su ubicación hacia la raíz del proyecto. Para solucionar esto nos dirigimos al archivo `frontend/tests/e2e/plugins/index.js` y reemplazamos completamente su contenido: ```javascript const path = require('path') module.exports = (on, config) => { const fixturesFolder = path.join(path.resolve('.'), '../fixtures') return Object.assign({}, config, { fixturesFolder, integrationFolder: 'tests/e2e/specs', screenshotsFolder: 'tests/e2e/screenshots', videosFolder: 'tests/e2e/videos', supportFile: 'tests/e2e/support/index.js' }) } ``` Debido a que hicimos una modificación en una configuración de arranque de `Cypress`, debemos reiniciar su ejecución. Una vez que este corriendo `Cypress` veremos que aún persiste un error y seguimos viendo un `GET 404 /api/products`. En la siguiente imagen se muestra como tenemos 2 terminales corriendo. En la de Frontend (de Cypress) identificamos la llamada que está dando `error 404`: ![Imagen de la salida de Cypress en la terminal](images/03-monorepo-backend-03.png) A pesar de que ya tenemos un servidor que responde al endpoint `/api/products` con el método GET, nuestra aplicación hace la solicitud a `http://localhost:8080` y nuestro servidor corre en la url `http://localhost:3000`. Para solucionar esto tendremos que una vez más detener la ejecución de Cypress, pero esta vez modificaremos la configuración de Vue (internamente configura webpack-dev-server). Para ello iremos al archivo `frontend/vue.config.js` y reemplazamos todo su contenido por lo siguiente: ```javascript module.exports = { transpileDependencies: [ 'vuetify' ], devServer: { proxy: { '^/api': { target: 'http://localhost:3000' } } } } ``` Esto permitirá que, mientras desarrollamos, las llamadas XHR al servidor sean redireccionadas hacia `localhost:3000`. Esto tiene sentido solo en el ambiente local de desarrollo ya que en producción las llamadas desde el Frontend hacia el Backend serán bajo el mismo dominio y puerto. Ahora volvemos a correr el comando `npm run test:e2e` dentro de la carpeta `frontend`. Veremos como siguen fallando pero la respuesta de la llamada al servidor ahora dice `GET 200 /api/products` como se muestra en la siguiente imagen: ![Imagen Cypress con un XHR con status 200](images/03-monorepo-backend-04.png) Y lo siguiente en la salida de la terminal del servidor: ![Imagen Nodemon con 2 llamadas con status 200](images/03-monorepo-backend-05.png) Podemos ver que se hicieron 2 llamadas al endpoint `/api/products`. Esto es debido a que en la primera prueba de autenticación exitosa también se hace un llamado a la página de productos. Ahora iremos al archivo `backend/src/server.js` y lo reemplazaremos por lo siguiente: **backend/src/server.js** ```javascript const express = require('express') const app = express() const port = 3000 app.use('/api/products', (request, response) => { const statusCode = 200 const products = [ { id: 1, name: 'Epiphone Explorer Gothic ', description: 'Guitarra color negro', image: 'https://images.unsplash.com/photo-1550985616-10810253b84d?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=742&q=80', code: '0001' }, { id: 2, name: 'Cordoba Mini Bass', description: 'Bajo pequeño tipo ukelele. Excelente sonido de bajo.', image: 'https://images.unsplash.com/photo-1556449895-a33c9dba33dd?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=2734&q=80', code: '0002' }, { id: 3, name: 'Distorsión Custom Badass 78', description: 'Peda del guitarra de distorsión.', image: 'https://images.unsplash.com/photo-1527865118650-b28bc059d09a?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=668&q=80', code: '0003' }, { id: 4, name: 'Distorsión TMiranda Bass Drive BD-1', description: 'Pedal del bajo de distorsión.', image: 'https://images.unsplash.com/photo-1614963590047-0b8b9daa3eb7?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=2089&q=80', code: '0004' }, { id: 5, name: 'Looper Hotone Wally', description: 'Pedal de looper. Super portable.', image: 'https://images.unsplash.com/photo-1595167151695-dfb4846e70f8?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=668&q=80', code: '0005' } ] console.log(`GET with status code ${statusCode} in /api/products endpoint`) return response .status(statusCode) .json(products) }) app.listen(port, () => { console.log(`App server listening on port ${port}`) }) ``` Como verás, al que en el cápitulo anterior en el Frontend, hemos copiado la lista del archivo `fixtures/products.json` para responder esa lista de productos. Una vez guardemos el archivo `backend/src/server.js` veremos que la terminal donde está corriendo el servidor dice ```bash [nodemon] restarting due to changes... [nodemon] starting `node src/server.js` ``` Así que nuestro servidor ya está actualizado. Ahora simplemente presionamos en botón recargar en Cypress y veremos que nuestras pruebas nuevamente están pasando. ![Imagen de Cypress con las pruebas pasando](images/03-monorepo-backend-06.png) Con esto ya tenemos nuestra plataforma funcionando. Pero aun nos quedan algunas cosas básicas por resolver. Una de ellas es la seguridad de nuestro servidor. Podemos corroborar que nuestro servidor no valida quién hace la petición escribiendo `http://localhost:3000/api/products` en el navegador. Veremos que la información está expuesta sin ningún método de autenticación. ![Endpoint responde en el navegador sin autenticación](images/03-monorepo-backend-07.png) En el siguiente capítulo solucionaremos esto permitiendo que la autenticación a Firebase nos entregue un Token de autorización que validaremos en el Backend y así darle seguridad a nuestro servidor. Antes de ir al siguiente capítulo vamos a detener el código del servidor y de Cypress. En cualquier de las ventanas de la terminal nos saldremos del directorio y vamos a la raíz del proyecto (importante para que git agregue todo incluyendo frontend, backend, fixtures, etc) y ejecutamos lo siguiente: ```bash git add . git commit -m \"feature(products): se agrega Backend con un endpoint de productos para ser consumido desde el Frontend para completar la funcionalidad de listar productos y autenticarse en la aplicación\" ``` Aún cuando tenemos el endpoint descubierto, es importante notar que nuestras historias de usuario están corroboradas mediante pruebas y tenemos, en ambiente de desarrollo, la funcionalidad completa (feature). En adelante lo que sigue es aumentar la calidad de nuestra aplicación para hacerla más segura y flexible a los cambios. Echemos un vistazo al resumen de nuestras historias de usuario que representan toda la funcionalidad que hemos desarrollado hasta el momento: ```ruby Funcionalidad: login de la aplicación Escenario: login con credenciales inválidas Como un usuario no registrado Cuando ingreso a la aplicación Y completo el campo username con 'info' Y el campo password con 'visitor' Entonces debería permanecer en la misma página Escenario: login con credenciales válidas Como un usuario no registrado Cuando ingreso a la aplicación Y completo el campo username con 'test-e2e@boolean.cl' Y el campo password con 'booleanacademia' Entonces debería ver la página de productos ``` ```ruby Funcionalidad: página de productos Escenario: listado simple Como un usuario que inició sesión en la aplicación Cuando ingreso a la página de productos Entonces debería ver una lista de productos ``` | ⬅️ Escribiendo Pruebas E2E siguiendo la metodología BDD | Validar autenticación en el Backend ➡️ | . ",
    "url": "/docs/03-monorepo-backend.html",
    "relUrl": "/docs/03-monorepo-backend.html"
  },"7": {
    "doc": "Autenticación en backend",
    "title": "Autenticación en backend",
    "content": "# Validar autenticación en el Backend Firebase hace muy simple la comprobación de tokens de autorización en el Backend. En resumen, debemos enviar una cabecera específica desde el Frontend y con la librería de Firebase integrada a nuestro backend podremos validar que las solicitudes sean de un usuario autenticado. Esto llevará consigo una seríe de consideraciones relacionadas al manejo de variables de entorno. El primer paso de esta etapa es la instalación de la librería `firebase-admin` en nuestro backend. Como ejercicio de estudio, es bueno tener corriendo las pruebas de front y relacionar los distintos códigos de error con el estado del servidor siguiente. Ejecutamos las pruebas e2e sin encender el servidor y veremos que la solicitud GET a `/api/products` retorna error 500. Ahora, en una terminal paralela ingresamos a la carpeta backend e ingresamos la siguiente instrucción: ```bash npm i firebase-admin ``` En esta parte podemos encender el servidor con `npm run dev`. Al recargar Cypress veremos que todas pruebas vuelven a pasar, pero aún no verificamos nada en el servidor. Para esto reemplaza el contenido del archivo `backend/src/server.js` con lo siguiente: ```javascript const express = require('express') const admin = require('firebase-admin') const app = express() const port = 3000 admin.initializeApp({credential: admin.credential.applicationDefault()}) app.use('/api', (request, response, next) => { const headerToken = request.headers.authorization; if (!headerToken) { return response.status(401).json({ message: 'No token provided' }) } const [authorizationType, tokenValue] = headerToken.split(' ') if (headerToken && authorizationType.toLowerCase() !== 'bearer') { return response.status(401).json({ message: 'Invalid token' }) } admin .auth() .verifyIdToken(tokenValue) .then(() => next()) .catch((error) => { console.error(error.message) response.status(403).json({ message: 'Could not authorize' }) }) }) app.use('/api/products', (request, response) => { const statusCode = 200 const products = [ { id: 1, name: 'Epiphone Explorer Gothic ', description: 'Guitarra color negro', image: 'https://images.unsplash.com/photo-1550985616-10810253b84d?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=742&q=80', code: '0001' }, { id: 2, name: 'Cordoba Mini Bass', description: 'Bajo pequeño tipo ukelele. Excelente sonido de bajo.', image: 'https://images.unsplash.com/photo-1556449895-a33c9dba33dd?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=2734&q=80', code: '0002' }, { id: 3, name: 'Distorsión Custom Badass 78', description: 'Peda del guitarra de distorsión.', image: 'https://images.unsplash.com/photo-1527865118650-b28bc059d09a?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=668&q=80', code: '0003' }, { id: 4, name: 'Distorsión TMiranda Bass Drive BD-1', description: 'Pedal del bajo de distorsión.', image: 'https://images.unsplash.com/photo-1614963590047-0b8b9daa3eb7?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=2089&q=80', code: '0004' }, { id: 5, name: 'Looper Hotone Wally', description: 'Pedal de looper. Super portable.', image: 'https://images.unsplash.com/photo-1595167151695-dfb4846e70f8?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=668&q=80', code: '0005' } ] console.log(`GET with status code ${statusCode} in /api/products endpoint`); return response .status(statusCode) .json(products) }) app.listen(port, () => { console.log(`App server listening on port ${port}`); }) ``` Si quieres conocer el detalle de cómo integrar firebase al servidor, revisa la siguiente [documentación](https://firebase.google.com/docs/admin/setup#add-sdk) Con esto, al recargar las pruebas veremos que el error pasó de 500 a 401, es decir, el servidor está revisando que las solicitudes tengan la cabecera de autorización y cómo no hemos configurado eso en el Frontend la aplicación entrega el mensaje y códigos especificados en la primera sentencia `if` configurada en el Middleware configurado para todas las peticiones hacia los endpoint encabezados por la ruta `/api`. Para revisar en Cypress como salieron las peticiones al servidor puedes acceder a las herramientas para desarrolladores al igual que en cualquier navegador moderno. Haciendo esto nuestras pruebas se ven como en la siguiente imagen: ![No token provided](images/04-firebase-sdk-backend-01.png) Lo mínimo para volver a pasar las pruebas sería agregar la cabecera correspondiente en el Frontend. Esto lo logramos reemplazamos el archivo `frontend/src/store/index.js` con el siguiente contenido: ```javascript import Vue from 'vue' import Vuex from 'vuex' import axios from 'axios' import { Auth } from '@/firebase' Vue.use(Vuex) export default new Vuex.Store({ state: { products: [] }, mutations: { SET_PRODUCTS (store, products) { store.products = products } }, actions: { async getProducts (actionContext) { const { commit } = actionContext const productsURL = '/api/products' try { const token = await Auth.currentUser?.getIdToken(true) const response = await axios.get(productsURL, { headers: { Authorization: `Bearer ${token}` } }) commit('SET_PRODUCTS', response.data) } catch (error) { console.log(error) } } }, modules: { } }) ``` Con esto en su lugar, recargamos Cypress y la terminal de Express indicará el siguiente mensaje de error: ![Imagen que muestra error \"no token provided\" en Cypress](images/04-firebase-sdk-backend-02.png) Esto sucede cuando el SDK de firebase-admin no logra acceder la variable de entorno `GOOGLE_APPLICATION_CREDENTIALS`. Para entender más en detalle el porque de esto puedes revisar la siguiente sección de la documentación de Firebase en [este enlace](https://firebase.google.com/docs/admin/setup?hl=es-419#initialize-sdk). Para configurar esta variable será descargar el archivo de **cuenta de servicio** de Firebase entrando a la siguiente url: ``` https://console.firebase.google.com/project//settings/serviceaccounts/adminsdk ``` Si lo hacemos correctamente deberíamos ver algo como la siguiente imagen: ![Imagen que muestra la interfaz de Firebase para descargar un archivo de cuenta de servicio](images/04-firebase-sdk-backend-03.png) Presionamos el botón `Generate new private key` para generar el archivo que vamos a utilizar para autenticarnos al SDK de Firebase Admin. Veremos un mensaje de advertencia que nos indicará que tengamos cuidado de mantener este archivo confidencial. ![Imagen que muestra advertencia de la creación del archivo de cuenta de servicio](images/04-firebase-sdk-backend-04.png) Al presionar el botón `Generate key`se descargará un archivo con extensión `.json`. Vamos a renombrarlo con el nombre `firebase-service-account.json` y luego lo moveremos hacia la raíz del directorio `backend` en nuestro proyecto. Al hacer esto nuestro directorio debería quedar como el siguiente esquema: ``` └─ backend └─ node_modules └─ src server.js firebase-service-account.json { console.log(`App server listening in mode ${environment} on port ${port}`); }) ``` Cómo podrás notar quitamos el puerto `3000` para asignar el puerto provisto por el ambiente de ejecución. En este caso puntual haremos esto porque más adelante subiremos este servidor a HEROKU y en su arquitectura nos inyectará esta variable. Si quieres ver más detalles respecto de esto puedes ver [este enlace](https://devcenter.heroku.com/articles/dynos#common-runtime-networking) También modificamos el mensaje que aparece cuando nuestro servidor esta escuchando las peticiones al puerto especificado. Al guardar el archivo `backend/src/server.js` deberíamos ver un mensaje como el siguiente: ```bash nodemon] restarting due to changes... [nodemon] starting `node src/server.js` App server listening in mode development on port 3000 ``` Ahora al recargar las pruebas desde Cypress podemos ver que una vez más las pruebas están pasando. ![Imagen que muestra pruebas de Cypress pasando nuevamente](images/04-firebase-sdk-backend-05.png) Ahora las peticiones al endpoint `GET /api/products` serán seguras y solo válidas para usuarios que se hayan autenticado a través de Firebase. La ruta en el Backend está protegida, pero desde el Forntend no debiésemos poder entrar directamente a la ruta `/productos`. Para proteger la ruta debemos implementar la `guard clause` en el router de Vue. Debemos reemplazar el archivo de rutas por lo siguiente: ```javascript import Vue from 'vue' import VueRouter from 'vue-router' import Login from '../views/Login.vue' import Products from '../views/Products.vue' import { Auth } from '@/firebase' Vue.use(VueRouter) const routes = [ { path: '/', name: 'Login', component: Login }, { path: '/productos', name: 'Products', component: Products, meta: { login: true } } ] const router = new VueRouter({ mode: 'history', routes }) router.beforeEach((to, from, next) => { const user = Auth.currentUser const authRequired = to.matched.some(route => route.meta.login) if (!user && authRequired) { next('/') } else { next() } }) export default router ``` Ahora es un buen momento para un nuevo commit. Debemos detener el uno se los servidores y ir a la raíz del proyecto. Ahí las instrucciones serían las siguientes: ```bash git add . git commit -m \"refactor(backend-firebase): Se agregó firebase-admin al backend para validar que las solicitudes estén autenticadas en las rutas /api\" ``` Nuestro siguiente objetivo será dejar de enviar información estática desde el servidor y conectarnos a una base de datos. Utilizaremos los Fixtures para mantener la consistencia entre los datos de la base de datos y los verificados por Cypress en las pruebas. | ⬅️ Reorganización del proyecto como un repositorio monolítico y agregar Backend | Agregando base de datos utlizando Sequelize ➡️ | . ",
    "url": "/docs/04-firebase-sdk-backend.html",
    "relUrl": "/docs/04-firebase-sdk-backend.html"
  },"8": {
    "doc": "Base de datos en desarrollo",
    "title": "Base de datos en desarrollo",
    "content": "# Agregando base de datos en desarrollo En esta sección configuraremos una opción muy común para persistir los datos que gestionará la aplicación. Nos referimos a las bases de datos relacionales, las que vienen en un montón de dialectos diferentes (psql, mysql, sqlite, oracle, etc), pero para no tener que decidir ahora cual usar, vamos a emplear una librería que nos entregará una capa de abstracción superior y que podemos configurar según las necesidades de cada entorno (desarrollo, producción, staging, etc). En el caso de Nodejs la librería más popular es `Sequelize`. Además de ser un traductor para los diferentes motores específicos de bases de datos, Sequelize es un ORM que entrega muchas facilidades para mantener sincronizada nuestra aplicación con el modelo de datos. Para usar Sequelize nos aseguramos de navegar en la carpeta `backend` y ejecuraremos los siguientes comandos: ```bash npm i sequelize npm i sequelize-cli sqlite3 --save-dev ``` Con estos comandos hemos agregado `Sequelize` como dependencia general y `Sequelize-cli` y `Sqlite3` como dependencias de desarrollo. Estás últimas nos permitirán modelar de forma más ágil y ligera nuestras bases de datos de desarrollo. Más adelante, cuando estemos próximos al despliegue a producción seleccionaremos y configuraremos la base de datos para el ambiente productivo. Para no tener que instalar el CLI de Sequelize en forma global, podemos exponer el comando desde el mismo directorio node_modules del proyecto y así usarlo de forma local. Para eso hay que modificar el archivo `backend/package.json` de la siguiente forma: ```javascript ... \"scripts\": { \"start\": \"nodemon src/server.js\", \"sequelize\": \"sequelize\", \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, ... ``` Sequelize-cli por defecto creará los modelos y las migraciones en la carpeta raíz, pero para definir que estos archivos se creen dentro del directorio `backend/src` (debido a la estructura de directorio que estamos utilizando) debemos configurarlo mediante un archivo denominado `.sequelizerc` en la carpeta `backend` con el siguiente contenido: ```javascript const path = require('path') module.exports = { 'config': path.resolve('./src/config', 'config.json'), 'models-path': path.resolve('./src/models'), 'seeders-path': path.resolve('./src/seeders'), 'migrations-path': path.resolve('./src/migrations') } ``` Ahora podemos ejecutar en la terminal de Backend el siguiente comando: ```bash npm run sequelize init ``` Esto creará las carpetas `/config`, `/models`, `/config` y `/seeders` dentro del directorio `backend/src`. Este último luego de los comandos que hemos ejecutado debería verse como el siguiente esquema: ```bash ├── node_modules ├── src ├── config ├── migrations ├── models ├── seeders server.js .sequelizesrc firebase-service-account.json nodemon.json package-lock.json package.json ``` Ahora continuaremos el desarrollo modificando el dialecto en el entorno de desarrollo. Por defecto es `mysql` pero usaremos `sqlite` debido a que es más simple de mantener. Para esto modificamos el archivo `backend/src/config/config.json` ```javascript \"development\": { \"username\": \"root\", ... \"host\": \"local.database.sqlite3\", \"dialect\": \"sqlite\" }, ``` Ya estamos en condiciones de crear el primer modelo. En este caso crearemos el modelo `Product` con los atributos acordados en los Fixtures. En la terminal del backend ejecutaremos el siguiente comando. ```javascript npm run sequelize model:generate -- --name Product --attributes name:string,description:string,code:string,image:string ``` Como profundizamos en el curso, la estructura de la base de datos debe ser modificada utilizando scripts de migración. El comando anterior creó un script que agrega una tabla con el nombre del modelo más los atributos como columnas. Sequelize agrega por defecto el atributo id de típo numérico autoincremental y considera el caso de los atributos `created_at` y `updated_at`. El valor por defecto de estos dos atributos debemos establecerlo nosotros. Modificaremos el archivo de migración en `backend/src/migrations/[timestamp-generado-por-sequelize]-create-product.js` reemplazando el valor de ambos campos con lo que sigue: ```javascript createdAt: { allowNull: false, type: Sequelize.DATE, defaultValue: Sequelize.literal(\"CURRENT_TIMESTAMP\"), }, updatedAt: { allowNull: false, type: Sequelize.DATE, defaultValue: Sequelize.literal(\"CURRENT_TIMESTAMP\"), } ``` Para que esta migración modifique la estructura, debemos ejecutar el archivo de migración con el siguiente comando: `npm run sequelize db:migrate` Para cargar los datos iniciales en el ambiente de desarrollo creamos un archivo conocido como Seed con el siguiente comando: `npm run sequelize seed:generate -- --name load-products` Esto tan solo crea un archivo dentro de la carpeta `/seeders` que con simple javascript permite ingresar datos a nuestras tablas. Reemplazaremos todo el contenido del archivo creado. El nombre del archivo es: `backend/src/seeders/[timestamp-generado-por-sequelize]-load-products.js` ```javascript const path = require('path') const fixturesFolder = path.join(path.resolve('.'), '../fixtures') const products = require(`${fixturesFolder}/products.json`) const tableName = 'Products'; module.exports = { up: async (queryInterface) => { await queryInterface.bulkDelete(tableName, null, { truncate: true }) await queryInterface.bulkInsert(tableName, products, {}) }, down: async (queryInterface) => { await queryInterface.bulkDelete(tableName, null, { truncate: true }) } } ``` Al ejecutar el siguiente comando estamos copiando los datos definidos en los fixtures a la base de datos de desarrollo. `npm run sequelize db:seed:all` Es importante notar, que a pesar de que es posible ingresar datos a la base de muchas formas, es mejor seguir esta, ya que los fixtures representan una parte importante del modelo de datos y representan el acuerdo común entre Backend, Frontend y el Dominio de Negocio de nuestra aplicación. Podemos notar que en la raíz del directorio `backend` se creó un archivo llamado `local.database.sqlite3`. Si contamos con un visor de bases de datos sqlite, podemos cargar este archivo y ver gráficamente el resultado como en la siguiente imágen: ![visor de bdd](images/05-database-sequelize-01.png) Recomendamos `DB Browser for SQLite` que lo puedes encontrar en el [siguiente enlace](https://sqlitebrowser.org/dl/) Ahora agregaremos el archivo `local.database.sqlite3` a `.gitignore` que hasta el momento debería verse de la siguiente manera: ``` .DS_Store node_modules dist /tests/e2e/videos/ /tests/e2e/screenshots/ firebase-service-account.json local.database.sqlite3 # local env files .env.local .env.*.local # Log files npm-debug.log* yarn-debug.log* yarn-error.log* pnpm-debug.log* # Editor directories and files .idea .vscode *.suo *.ntvs* *.njsproj *.sln *.sw? ``` Con todo esto ya tenemos nuestro ambiente de Base de datos montado en el ambiente de desarrollo. Solo falta incorporar que la respuesta del servidor entregue los datos desde la BDD #### Agregar modelos de base de datos como respuesta a la llamada al Servidor Volveremos a dividir nuestro entorno de trabajo en 2 ventanas (o pestañas) de la terminal. Una para el Frontend y otra para el Backend como lo hemos venido haciendo hasta el momento. - Primero para el Backend ejecutamos `npm run dev` - Luego para el Frontend ejecutamos `npm run test:e2e` y presionamos el botón `Run all specs` en la interfaz de Cypress. Todas las pruebas deberían estar pasando sin problemas. Ahora modificaremos el archivo `backend/src/server.js` y lo reemplazaremos todo su contenido por lo siguiente: ```javascript const express = require('express') const admin = require('firebase-admin') const Models = require('./models') const app = express() const port = process.env.PORT const environment = process.env.NODE_ENV admin.initializeApp({credential: admin.credential.applicationDefault()}) app.use('/api', async (request, response, next) => { const headerToken = request.headers.authorization; if (!headerToken) { return response.status(401).json({ message: \"No token provided\" }) } const [authorizationType, tokenValue] = headerToken.split(\" \") if (headerToken && authorizationType.toLowerCase() !== \"bearer\") { return response.status(401).json({ message: \"Invalid token\" }) } try { await admin.auth().verifyIdToken(tokenValue) next() } catch (error) { console.error(error.message) response .status(403) .json({ message: \"Could not authorize\" }) } }) app.use('/api/products', async (request, response) => { let statusCode = 200 const Product = Models.Product; try { const products = await Product.findAll() console.log(`GET with status code ${statusCode} in /api/products endpoint`); return response .status(statusCode) .json(products) } catch (error) { const { message } = error; statusCode = 500; console.error(`GET with status code ${statusCode} in /api/products endpoint. Error: ${message}`) return response .status(statusCode) .json({ message }) } }) app.listen(port, () => { console.log(`App server listening in mode ${environment} on port ${port}`); }) ``` Hicimos una refactorización del archivo `backend/server.js` en el cual normalizaremos el uso de `async/await` para ejecutar Promesas y agregaremos un bloque `try/catch` para realizar una consulta a la base de datos para traer todos los productos utilizando los modelos de Sequelize y utilizando el método `Product.findAll` Cuando guardemos el archivo se recargará Nodemon y ahora podemos volver a recargar las pruebas y veremos que siguen pasando. Notaremos que ahora en la terminal la consulta a la base de datos aparece en la terminal como muestra la siguiente imagen: ![Imagen que muestra la consulta a la base de datos en la terminal del servidor](images/05-database-sequelize-02.png) Esto es Sequelize en acción realizando consultas SQL a la base de datos por nosotros. En ambiente de desarrollo es deseable poder ver las consultas que se van ejecutando, pero por seguridad y confidencialidad no es algo permitido en el entorno de producción. Esto debemos tenerlo presente en el paso a producción. Ya es momento de un nuevo commit. Debemos detener Frontend y Backend. Volvemos a la raíz del proyecto y escribimos lo siguiente en la terminal: ```bash git add . git commit -m \"refactor(backend-sequelize): Se agregó Sequelize para el manejo de modelos, migraciones y el ambiente de desarrollo para la base de datos\" ``` Con esto ya tenemos completa la funcionalidad de nuestra aplicación conectados a una Base de datos. En el próximo cápitulo escribiremos pruebas de software de integración tanto en Backend como Frontend de manera de asegurar que la calidad de la solución que hemos escrito no se vea afectada con las sucesivas modificaciones que se hagan en el futuro. | ⬅️ Validar autenticación en el Backend | Pruebas de software para Backend y Frontend ➡️ | . ",
    "url": "/docs/05-database-sequelize.html",
    "relUrl": "/docs/05-database-sequelize.html"
  },"9": {
    "doc": "Refactorización con pruebas I",
    "title": "Refactorización con pruebas I",
    "content": "# Refactorización utilizando pruebas de software en Backend En este punto la funcionalidad ya está completa, pero la organización del código se puede mejorar para aumentar su flexibilidad a los cambios que inevitablemente llegarán. Para esto necesitamos una forma de asegurar que no romperemos nada de lo que hemos logrado. La funcionalidad se debe mantener, pero la calidad del código debe aumentar. Para esto agregaremos pruebas de software para el código tanto en el Backend como en el Frontend. ### Pruebas de software en Backend Utilizaremos tres herramientas populares de Javascript para escribir y ejecutar pruebas: `jest`, `jest-cli` y `supertest`. Primero navegamos a la carpeta `/backend` y luego ejecutamos el siguiente comando: ```bash npm i --save-dev jest jest-cli supertest ``` Al igual que como lo hicimos con Sequelize-cli, vamos a exponer el comando de Jest para no tener que instalarlo globalmente. Eso es en el archivo `backend/package.json`. También vamos a cambiar el comando de test que viene por defecto. El archivo quedaría de la siguiente forma: ```javascript ... \"scripts\": { \"start\": \"nodemon src/server.js\", \"test\": \"jest --runInBand --coverage\", \"jest\": \"jest\", \"sequelize\": \"sequelize\" }, ... ``` Jest tiene la opción --init para configurar el entorno de pruebas. El comando a ejecutar es el siguiente: `npm run jest -- --init` Esto nos hará una pequeña serie de preguntas que debemos responder con lo siguiente: ![jest --init](images/06-testing-frontend-backend-01.png) Ahora continuaremos configurando una base de datos exclusivamente para la ejecución de pruebas. Para esto modificamos el archivo `backend/src/config/config.json` en la sección \"test\". ```javascript \"test\": { \"username\": \"root\", ... \"host\": \"test.database.sqlite3\", \"dialect\": \"sqlite\", \"logging\": false }, ``` Durante la ejecución de las pruebas se creará una nueva bases de datos que no necesitamos incluir en el repositorio, por lo que agregaremos el nombre de la base de datos de prueba `test.database.sqlite3` al `.gitignore`. Para probar el backend vamos a crear la carpeta `/tests` dentro del directorio `backend` y crearemos una prueba simple para revisar que esté todo bien configurado. A este archivo lo llamaremos `auth.test.js` ya que es la primera funcionalidad de describimos de nuestro servidor. Su contenido es el siguiente: ```javascript const server = require('../src/server') describe('Auth middleware',() => { it('works', () => { expect(true).toEqual(true) }) }) ``` Esto lo ejecutamos con el comando que configuramos `npm test`. La salida en la terminal de esta ejecución es la siguiente: ![error-async](images/06-testing-frontend-backend-02.png) Tenemos resultados confusos, ya que en concreto la prueba si pasa, pero vemos una indicación en rojo de que estamos ejecutando `console.log`. En este caso es Express en la llamada `app.listen` que hace correr un proceso en forma indefinida y jest queda ejecutándose. Entonces debemos separar lo que vamos a probar (la lógica) de lo que ejecuta el servidor (`listen`). Logramos esto separando el archivo `server.js` para que quede de la siguiente forma: ```javascript const app = require('./app') const port = process.env.PORT const environment = process.env.NODE_ENV app.listen(port, () => { console.log(`App server listening in mode ${environment} on port ${port}`) }) ``` El resto del contenido lo agregaremos aun archivo llamado `app.js` también en la raíz de Backend con lo siguiente: ```javascript const express = require('express') const admin = require('firebase-admin') const Models = require('./models') const app = express() admin.initializeApp({credential: admin.credential.applicationDefault()}) app.use('/api', async (request, response, next) => { const headerToken = request.headers.authorization if (!headerToken) { return response.status(401).json({ message: 'No token provided' }) } const [authorizationType, tokenValue] = headerToken.split(' ') if (headerToken && authorizationType.toLowerCase() !== 'bearer') { return response.status(401).json({ message: 'Invalid token' }) } try { await admin.auth().verifyIdToken(tokenValue) next() } catch (error) { console.error(error.message) response .status(403) .json({ message: 'Could not authorize' }) } }) app.use('/api/products', async (request, response) => { let statusCode = 200 const Product = Models.Product; try { const products = await Product.findAll() console.log(`GET with status code ${statusCode} in /api/products endpoint`) return response .status(statusCode) .json(products) } catch (error) { const { message } = error statusCode = 500 console.error(`GET with status code ${statusCode} in /api/products endpoint. Error: ${message}`) return response .status(statusCode) .json({ message }) } }) module.exports = app ``` Y modificamos la prueba para requerir el archivo `app.js`: ```javascript const app = require('../src/app') describe('Auth middleware',() => { it('works', () => { expect(true).toEqual(true) }) }) ``` Con estos ajustes la salida de las pruebas queda como indica la siguiente imagen: ![jest simple test passing](images/06-testing-frontend-backend-03.png) #### Casos de la funcionalidad para definir pruebas En este momento el servidor tiene las siguientes características: - Valida que las solicitudes a `/api` estén autenticadas con 4 casos posibles. 3 casos en los cuales respondemos un código de error y uno en el cuál resulta exitoso y se deja pasar la solicitud. EL resumen el archivo server tiene los siguientes bloques de código para cada uno de los casos. **backend/src/server.js** ```javascript app.use('/api', async (request, response, next) => { if (!headerToken) { // Caso 1 error: no se envía la cabecera \"Authorization\" } if (headerToken && authorizationType.toLowerCase() !== \"bearer\") { // Caso 2 error: se envía una cabecera \"Authorization\" que no es del tipo \"Bearer\" } try { // Caso 3 éxito: La solicitud fue validada exitosamente // y la solicitud ingresa al servidor ejecutando la función \"next\" } catch (error) { // Caso 4 error: La librería \"firebase-admin\" no valida el token enviado } }) ``` - Las solicitudes ya autenticadas que consultan `/api/products` pueden tener 2 casos posibles al hacer consultas a la base de datos. **backend/src/server.js** ```javascript app.use('/api/products', async (request, response) => { try { // Caso 1 éxito: Se consulta la base de datos exitosamente } catch (error) { // Caso 2 error: Ocurre un error al consultar la base de datos } }) ``` Estas son las funcionalidades que debemos mantener y que deben resistir el proceso de refactorización. Es una buena práctica primero previsualizar los casos a los cuales vamos a escribir las pruebas así tenemos claro que código está involucrado en cada uno de los casos y será más fácil escribir la implementación de la prueba. #### Implementación de pruebas sobre el Middleware de validación de solicitudes autorizadas Vamos a escribir las pruebas que definimos para los casos que describimos anteriormente. ##### Caso 1 error: no se envía la cabecera \"Authorization\" Resultado esperado ``` Retorna 401 y un mensaje \"No token provided\" cuando no viene la cabecera de autorización ``` Vamos a escribir el código para representar este caso como indica el siguiente código: **backend/tests/auth.test.js** ```javascript const supertest = require('supertest') const app = require('../src/app') describe('Auth middleware',() => { it(\"returns 401 when there is no authorization header\", async () => { const response = await supertest(app) .get('/api/any-endpoint') .expect(401) expect(response.body).toMatchObject({ message: \"No token provided\" }) }) }) ``` Podemos notar como a partir de la librería `Supertest` podemos simular una solicitud al servidor sin necesidad de crear una real pasándole el módulo de express que en nuestro caso se exporta a través del valor `app`. Esto permite a `Supertest` conocer la configuración de las rutas que hemos definido para nuestros endpoints y hacer la simulación. En adelante vamos a complementar este archivo agregando los bloques `it` dentro del bloque `describe` en el mismo orden que hicimos nuestro análisis ##### Caso 2 error: se envía una cabecera \"Authorization\" que no es del tipo \"Bearer\" Resultado esperado ``` Retorna 401 y un mensaje \"Invalid token\" cuando el token no es de tipo Bearer ``` El código que representa este caso es como indica el siguiente código: ```javascript it('returns 401 when the token is not a bearer token', async ()=>{ const response = await supertest(app) .get('/api/fake') .set('Authorization','Token faketoken') .expect(401) expect(response.body).toMatchObject({ message: 'Invalid token' }) }) ``` ##### Caso 3 éxito: La solicitud fue validada exitosamente y la solicitud ingresa al servidor ejecutando la función \"next\" Resultado esperado ``` Al validar el token deja pasar la petición ejecutando la función \"next\" ``` Este caso no lo implementaremos acá ya que cuando hagamos las pruebas del endpoint `GET /api/products` estaremos pasando por este middleware y será implícito que la prueba pasa por la función `next` ##### Caso 4 error: La librería \"firebase-admin\" no valida el token enviado Resultado esperado ``` Retorna 403 y un mensaje \"Could not authorize\" cuando el token es de tipo Bearer, pero no es válido ``` En este caso debemos crear un mock de la librería `firebase-admin` para simular que el llamado al método `verifyIdToken` tome el comportamiento que necesitemos para la prueba. Primero modificaremos las funciones que utilizamos de `firebase-admin` para que la prueba se ejecute sin errores: ```javascript const supertest = require('supertest') const app = require('../src/app') const admin = require('firebase-admin'); jest.mock('firebase-admin', () => ({ auth: jest.fn() .mockReturnValue({ verifyIdToken: jest.fn() }), credential: { applicationDefault: jest.fn(), }, initializeApp: jest.fn() })) ... ``` Ahora sí podemos agregar el último `it` en el que forzaremos un rechazo de la promesa en la función `verifyIdToken`, para simular que se entregó un token inválido. ```javascript it('returns 403 when an invalid token is passed',async () => { admin.auth().verifyIdToken.mockRejectedValue(new Error()) const response = await supertest(app) .get('/api/fake') .set('Authorization', 'Bearer faketoken') .expect(403) expect(response.body).toMatchObject({ message: 'Could not authorize' }) }) ``` Ejecutamos y vemos que en la ultima prueba jest incluso nos muestra el `console.error` que se debe ejecutar en el código de la aplicación cuando llega un token inválido. Lo puedes ver en el siguiente screenshot: ![jest auth test](images/06-testing-frontend-backend-04.png) Con todo lo anterior el código completo del archivo `auth.test.js` queda de la siguiente forma: **backend/tests/auth.test.js** ```javascript const supertest = require('supertest') const app = require('../src/app') const admin = require('firebase-admin') jest.mock('firebase-admin', () => ({ auth: jest.fn().mockReturnValue({ verifyIdToken: jest.fn() }), credential: { applicationDefault: jest.fn(), }, initializeApp: jest.fn() })) describe('Auth middleware',() => { it('returns 401 when there is no authorization header', async () => { const response = await supertest(app) .get('/api/fake') .expect(401) expect(response.body).toMatchObject({ message: 'No token provided' }) }) it('returns 401 when the token is not a bearer token', async ()=>{ const response = await supertest(app) .get('/api/fake') .set('Authorization','Token faketoken') .expect(401) expect(response.body).toMatchObject({ message: 'Invalid token' }) }) it('returns 403 when an invalid token is passed',async () => { admin.auth().verifyIdToken.mockRejectedValue(new Error()); const response = await supertest(app) .get('/api/fake') .set('Authorization', 'Bearer faketoken') .expect(403) expect(response.body).toMatchObject({ message: 'Could not authorize' }) }) }) ``` Antes de continuar vamos a echar un vistazo a una nueva carpeta que se ha creado en la raíz del directorio `backend` llamada `coverage`. En su interior veremos otro directorio llamado `lcov-report` y en su interior un archivo `index.html` Si lo abrimos con un navegador web veremos algo como lo siguiente: ![Imagen que muestra reporte de cobertura en el navegador](images/06-testing-frontend-backend-05.png) Luego si hacemos click en `src` y luego en `app.js` veremos lo que muestra la siguiente imagen: ![Imagen que muestra reporte de cobertura en el navegador](images/06-testing-frontend-backend-06.png) Podemos ver claramente como es que el informe de cobertura nos muestra que aún no hemos escrito pruebas que ejecuten los códigos remarcados en la imagen. ⚠️ Ahora vamos a agregar al archivo `.gitignore` el directorio `coverage` porque es importante que este informe sea regenerado por cada ejecución de las pruebas pero no lo necesitamos como parte del repositorio. Seguimos adelante con las pruebas cuando la solicitud pasa el middleware de autorización y solicita el listado de productos. #### Implementación de pruebas para endpoints de productos Vamos a escribir las pruebas del endpoint `GET /api/products`: ##### Caso 1 éxito: Se consulta la base de datos exitosamente Resultado esperado ``` Retorna 200 y una lista de productos que previamente fueron insertados en la base de datos ``` Haremos un nuevo archivo dentro del directorio `backend/tests` llamado `products.test.js`. Este es un caso más complejo, porque debemos simular (usando dobles de prueba) que la solicitud cumple con los requisitos de autorización, de otra forma nuestro código no se ejecutará. Además necesitamos probar que la aplicación entrega el arreglo de productos definido en los Fixtures, por lo que hay agregar estos datos a la BDD antes de enviar la solicitud. Esto lo podemos lograr con las funciones `beforeAll` y `afterAll` que se ejecutarán al inicio y al final de todas las pruebas respectivamente con el objetivo de sincronizar la base de datos y correr las migraciones a través de `Models.sequelize.sync`. La prueba queda de la siguiente forma: **backend/tests/products.test.js** ```javascript const supertest = require('supertest') const admin = require('firebase-admin') const app = require('../src/app') const Models = require('../src/models') const productsFixture = require('../../fixtures/products.json') jest.mock('firebase-admin', () => ({ auth: jest.fn().mockReturnValue({ verifyIdToken: jest.fn() }), credential: { applicationDefault: jest.fn(), }, initializeApp: jest.fn() })) describe('/api/products', () =>{ beforeAll(async () => { await Models.sequelize.sync({ force: true }) admin.auth().verifyIdToken.mockResolvedValue(true) }) it('returns an array of products', async () => { await Models.Product.bulkCreate(productsFixture) const response = await supertest(app) .get('/api/products') .set('Authorization', 'Bearer valid-token') .expect(200) expect(response.body).toMatchObject(productsFixture) }) afterAll(async () => { await Models.sequelize.close() }) }) ``` ##### Caso 2 error: Ocurre un error al consultar la base de datos Resultado esperado ``` Retorna 500 y un mensaje con el error de la base de datos ``` Para hacer que la base de datos falle, lo que haremos será destruir la table `Products` a través de Sequelize utilizando el método `drop`. Agregaremos el siguiente bloque `it` bajo del que ya escribimos en el archivo `backend/tests/products.test.js` **backend/tests/auth.test.js** ```javascript it('returns 500 when the database throws error', async () => { await Models.Product.drop() const response = await supertest(app) .get('/api/products') .set('Authorization', 'Bearer valid-token') .expect(500) expect(response.body).toMatchObject({ message: 'SQLITE_ERROR: no such table: Products' }) }) ``` al correr el comando `npm test` deberíamos ver todas las pruebas pasando como muestra la siguiente imagen: ![Imagen que muestra todas las pruebas de Backend pasando](images/06-testing-frontend-backend-07.png) Podemos validar que ahora estamos cubriendo toda la funcionalidad construida hasta el momento con nuestras pruebas revisando tal como lo hicimos anteriormente en el archivo en el directorio `coverage`. ![Imagen que muestra la cobertura de las pruebas en el archivo app.js](images/06-testing-frontend-backend-08.png) Ahora con toda nuestra funcionalidad cubierta con las pruebas pasando, volvemos a refactorizar para dividir los controladores, middleware y rutas siguiendo los guías SOLID. Vamos a re-estructurar el proyecto para que quede de la siguiente forma ```bash ├── coverage ├── node_modules ├── src ├── config ├── controllers { const headerToken = request.headers.authorization; if (!headerToken) { return response.status(401).json({ message: 'No token provided' }) } const [authorizationType, tokenValue] = headerToken.split(' ') if (headerToken && authorizationType.toLowerCase() !== 'bearer') { return response.status(401).json({ message: 'Invalid token' }) } try { await admin.auth().verifyIdToken(tokenValue) next() } catch (error) { console.error(error.message) response .status(403) .json({ message: 'Could not authorize' }) } } ``` **backend/routes/index.js** ```javascript const express = require('express'); const router = express.Router(); const productsController = require('../controllers/products') router.get('/products', productsController.index); module.exports = router ``` **backend/app.js** ```javascript const express = require('express') const authMiddleware = require('./middleware/auth') const routes = require('./routes') const app = express() app.use('/api', authMiddleware) app.use('/api', routes) module.exports = app ``` Volvemos a correr el comando `npm test` y veremos que el informe de cobertura nos muestra la nueva distribución de los archivos que fueron ejecutados en las pruebas. ![Imagen que muestra la cobertura de las pruebas en la terminal](images/06-testing-frontend-backend-09.png) De esta manera logramos hacer una refactorización para ordenar y preparar al código del servidor para ser más escalable para los futuros incrementos del código. Momento de un nuevo commit. Escribimos lo siguiente en la terminal: ⚠️ Debes están posicionado en la raíz del proyecto. ```bash git add . git commit -m \"refactor(backend-refactor): Se agregó set de pruebas de caracterización en el Backend y luego un refactor para dividir responsabilidades\" ``` | ⬅️ Agregando base de datos en desarrollo | Pruebas de software para Frontend ➡️ | . ",
    "url": "/docs/06-testing-backend.html",
    "relUrl": "/docs/06-testing-backend.html"
  },"10": {
    "doc": "Refactorización con pruebas II",
    "title": "Refactorización con pruebas II",
    "content": "# Refactorización utilizando pruebas de software en Frontend Continuamos caracterizando la aplicación para refactorizar y dejar la aplicación más flexible y mantenible. A diferencia de las pruebas que escribimos para el Backend, nuestra parte Frontend utiliza el framework VueJS y algunos plugins como Vuex y Vuetify. Esto agrega más de dificultad al momento de escribir las pruebas dado que debemos simular en cada una de ellas como si una aplicación Vue real estuviera funcionando incluyendo todas las cosas que configuramos. Para facilitar las cosas Vue ya trae integrada una librería llamada `@vue/test-utils` que nos permitirá hacer algunas cosas necesarias para ejecutar las pruebas. Si quieres aprender mucho más en profundidad como funciona y que cosas se pueden hacer puedes revisar [este enlace](https://github.com/vuejs/vue-test-utils/) Vuetify al ser una de las librerías que más usamos debido a que está incluida en todas las vistas de nuestra aplicación, necesita de una configuración especial para funcionar. El detalle y varios ejemplos de como hacer esto lo puedes revisar en la [sección dedicada a pruebas de software de la documentación de Vuetify](https://vuetifyjs.com/en/getting-started/unit-testing/) En resumen debemos configurar las pruebas para que se incluya globalmente en cada prueba. Tenemos que hacer dos pasos para esto. El primero es modificar el archivo `frontend/jest.config.js` para que quede así: ```javascript module.exports = { preset: '@vue/cli-plugin-unit-jest', setupFilesAfterEnv: [ './jest.setup.js' ] } ``` A continuación hay que crear el archivo `jest.setup.js` en la raíz del directorio `frontend` con el siguiente contenido ```javascript import Vue from 'vue' import Vuetify from 'vuetify' Vue.use(Vuetify) ``` Aprovecharemos de incluir la opción para analizar la cobertura de las pruebas de software modificando el archivo `package.json` en su sección `scripts`: ```javascript \"test:unit\": \"vue-cli-service test:unit --coverage\" ``` Una vez configurado esto comenzaremos a escribir las pruebas. #### Casos de la funcionalidad para definir pruebas En estos momentos el Frontend cuanta con las siguientes características - Una vista `Login` con un formulario con Vuetify que como finalidad ejecutar una función `login` que a su vez llama al método de autenticación de Firebase. En caso de ser exitoso, se redirige a la página de productos. El resúmen de ese código lo vemos en la siguiente imagen. **frontend/views/Login.vue** ```javascript ... async login () { if (this.validate()) { // Caso 1: Para un formulario válido ir a la página de productos si la autenticación fue exitosa await Auth.signInWithEmailAndPassword(this.email, this.password) this.$router.push({ name: 'Products' }) } // Caso 2: Para un formulario inválido NO llamamos al método de autenticación } ``` - También tenemos una vista llamada `Products` que al montarse en el DOM, invoca una acción de Vuex que desencadena que se guarde en el estado una variable llamada `products` con la lista de productos provenientes del servidor. Cuando este valor del estado se actualiza, nuestra vista reacciona a esto mostrando la lista de elementos. Lo vemos en el siguiente resumen **frontend/src/views/Products.vue** ```javascript ... computed: { ...mapState([ 'products' ]) }, methods: { ...mapActions([ 'getProducts' ]) }, created () { // Delegación de funcionalidad al store this.getProducts() } ... ``` **frontend/src/store/index.js** ```javascript actions: { async getProducts (actionContext) { const { commit } = actionContext const productsURL = '/api/products' try { // Caso 1: Al invocar a la acción getProducts al inicio de la vista se crea la lista de productos si el servidor responde exitosamente } catch (error) { // Caso 2: Al invocar a la acción getProducts al inicio de la vista NO se crea la lista de productos si el servidor responde con error } }, ... ``` #### Implementación de pruebas sobre la vista Login Vamos a escribir las pruebas para los casos que describimos anteriormente. ##### Caso 1: Para un formulario válido ir a la página de productos si la autenticación fue exitosa Resultado esperado ``` Al resolverse la promesa del método Auth.signInWithEmailAndPassword llama al método $router.push ``` La implementación de estas pruebas las escribiremos en un nuevo archivo llamado `Login.spec.js` en la carpeta `frontend/tests/unit` con el siguiente contenido: **frontend/tests/unit/Login.spec.js** ```javascript import { mount, createLocalVue } from '@vue/test-utils' import Vuetify from 'vuetify' import flushPromises from 'flush-promises' import App from '@/App.vue' import store from '@/store' import router from '@/router' import { Auth } from '@/firebase' jest.mock('@/firebase',()=> ({ Auth: { signInWithEmailAndPassword: jest.fn() } })) describe('Login.vue', () => { let localVue let vuetify beforeEach(() => { localVue = createLocalVue() vuetify = new Vuetify() Auth.signInWithEmailAndPassword.mockReset() router.push('/') }) it('Successful login redirects to products page', async () => { Auth.signInWithEmailAndPassword.mockResolvedValue() const wrapper = mount(App,{ localVue, vuetify, store, router }) wrapper.vm.$router.push = jest.fn() wrapper.find('[data-cy=username]').setValue('testlogin@boolean.cl') wrapper.find('[data-cy=password]').setValue('somepass') wrapper.find('[data-cy=login-btn]').trigger('click') await flushPromises() expect(wrapper.vm.$router.push).toHaveBeenCalledWith({ name: 'Products' }) }) }) ``` Elimina el `example.spec.js` que se creo junto con la aplicación. No lo usaremos. Vemos que incluimos un bloque `beforeEach` que nos permitirá hacer algunas acciones comunes relativas a las pruebas que escribiremos como por ejemplo dobles de prueba para la autenticación y su correspondiente `mockReset` para así asegurarnos de cumplir el [principio FIRST](http://agileinaflash.blogspot.com/2009/02/first.html) manteniendo a cada una de las pruebas \"aisladas\" entre si. Aprovechando que nuestras vistas están integradas con el enrutador de la aplicación, realizamos una navegación hacia la ruta `/` para asegurarnos que cuando la aplicación sea montada para las pruebas, se utilice la vista correcta. Ahora al mirar la prueba vemos como podemos configurar que la promesa asociada que retorna el método `Auth.signInWithEmailAndPassword` se resuelva con ayuda de jest en la función `mockResolvedValue`, al ser llamada en el contexto de la aplicación Vue esta no se resolverá automáticamente. Para poder lograr esto utilizaremos la librería `flush-promises`. Podemos ver una explicación desde la propia documentación de Vue relacionada a esto en [este enlace](https://vue-test-utils.vuejs.org/guides/testing-async-components.html#asynchronous-behavior-outside-of-vue) Vamos a instalar esta librería ejecutando lo siguiente en nuestra terminal preocupándonos de navagar hasta el directorio `frontend` en nuestro proyecto: ```bash npm install --save-dev flush-promises ``` Ahora ya estamos en condiciones de correr las pruebas que escribimos para la vista `Login.vue`. Al correr el comando `npm run test:unit` veremos lo siguiente: ![Imagen que muestra la ejecución de Jest](images/07-testing-frontend-01.png) Como vemos remarcado en la imagen aún no hemos abordado todos los casos para esta vista. Si vamos a la carpeta coverage que se debe haber creado en la raíz del directorio `frontend` y analizamos el archivo `frontend/src/Login.vue` veremos lo siguiente: ![Imagen que muestra métrica branch no cubierta](images/07-testing-frontend-02.png) Esto quiere decir que necesitamos una prueba que cubra el caso en el cual se llama a la función `login` pero el formulario no es válido. En adelante vamos a complementar este archivo agregando los bloques `it` dentro del bloque `describe` en el mismo orden que hicimos nuestro análisis ##### Caso 2: Para un formulario inválido NO llamamos al método de autenticación Resultado esperado ``` NO se llama al Auth.signInWithEmailAndPassword ``` la implementación de la prueba sería la siguiente: ```javascript it('Does not call Auth.signInWithEmailAndPassword if form is not valid', async () => { const wrapper = mount(App, { vuetify: new Vuetify(), store, router }) wrapper.find('[data-cy=login-btn]').trigger('click') expect(Auth.signInWithEmailAndPassword).not.toHaveBeenCalled() }) ``` Ahora al volver a ejecutar las pruebas vemos como ya hemos abarcado el 100% de los casos para esta vista en la siguiente imagen: ![Imagen que muestra cobertura total en el archivo Login.vue](images/07-testing-frontend-03.png) Podemos notar que con estas 2 pruebas ya hemos abarcado casi la mitad de lo que hemos construido hasta el momento. Nuestro enfoque será primero escribir pruebas de \"alto nivel\" que nos permitan abarcar la mayor cantidad de código posible de forma de tener una base de confianza que corrobore que al refactorizar escribiendo código mejor estructurado, la funcionalidad general de la aplicación se mantenga sin cambios. El archivo `frontend/tests/unit/Login.spec.js` debería haber quedado de la siguiente forma: ```javascript import { mount, createLocalVue } from '@vue/test-utils' import Vuetify from 'vuetify' import flushPromises from 'flush-promises' import App from '@/App.vue' import store from '@/store' import router from '@/router' import { Auth } from '@/firebase' jest.mock('@/firebase',()=> ({ Auth: { signInWithEmailAndPassword: jest.fn() } })) describe('Login.vue', () => { let localVue let vuetify beforeEach(() => { localVue = createLocalVue() vuetify = new Vuetify() router.push('/') Auth.signInWithEmailAndPassword.mockReset() }) it('Successful login redirects to products page', async () => { Auth.signInWithEmailAndPassword.mockResolvedValue() const wrapper = mount(App,{ localVue, vuetify: new Vuetify(), store, router }) wrapper.vm.$router.push = jest.fn() wrapper.find('[data-cy=username]').setValue('testlogin@boolean.cl') wrapper.find('[data-cy=password]').setValue('somepass') wrapper.find('[data-cy=login-btn]').trigger('click') await flushPromises() expect(wrapper.vm.$router.push).toHaveBeenCalledWith({ name: 'Products' }) }) it('Does not call Auth.signInWithEmailAndPassword if form is not valid', async () => { const wrapper = mount(App, { vuetify: new Vuetify(), store, router }) wrapper.find('[data-cy=login-btn]').trigger('click') expect(Auth.signInWithEmailAndPassword).not.toHaveBeenCalled() }) }) ``` #### Implementación de pruebas sobre la vista Products Pasaremos a hacer las pruebas para productos. ##### Caso 1: Al invocar a la acción getProducts al inicio de la vista se crea la lista de productos si el servidor responde exitosamente Resultado esperado ``` Al resolverse la promesa de axios, la vista agrega los elementos en función de la cantidad de productos que provienen del servidor ``` La implementación de estas pruebas las escribieremos en un nuevo archivo llamado `Products.spec.js` en la carpeta `frontend/tests/unit` con el siguiente contenido: **frontend/tests/unit/Products.spec.js** ```javascript import { mount, createLocalVue } from '@vue/test-utils' import axios from 'axios' import flushPromises from 'flush-promises' import Vuetify from 'vuetify' import App from '@/App.vue' import store from '@/store' import router from '@/router' import products from '../../../fixtures/products.json' jest.mock('axios',() => ({ get: jest.fn() })) jest.mock('@/firebase',() => ({ Auth: { currentUser: { name: 'dummyUser', getIdToken: () => 'fakeToken' } } })) describe('Product.vue',() => { let localVue let vuetify beforeEach(() => { localVue = createLocalVue() vuetify = new Vuetify() store.replaceState({ products: [] }) axios.get.mockReset() router.push('/') }) it('Shows a list of products when the server response successfully', async () => { const wrapper = mount(App,{ localVue, vuetify, store, router }) axios.get.mockResolvedValue({ data: products }) router.push( { name: 'Products' } ) await flushPromises() expect(wrapper.findAll('[data-cy=product-item]')).toHaveLength(products.length) expect(store.state.products).toEqual(products) }) }) ``` Nos damos cuenta que las pruebas al igual que en el caso anterior requieren configuración como dobles de prueba (1 Mock y 1 Stub) y podemos notar como ahora en el bloque `beforeEach` incluimos `store.replaceState`. Esto lo deberemos hacer en cada prueba que tenga computada atributos del Store de Vuex para asegurarnos que el estado se reinicia en cada prueba y así estas se mantienen aisladas entre sí como recordamos en las pruebas de la vista anterior. Si miramos la prueba notamos que en este caso como la llamada a la acción de Vuex que desencadena que se configure el valor del estado `products` se hace en el método del ciclo de vida `created` del componente, por esto forzamos a que esto ocurra navegando hacia la ruta de la página de productos a través del router utilizando `router.push` Al correr las pruebas veremos lo que muestra la siguiente imagen: ![Imagen que muestra falta de cobertura en store](images/07-testing-frontend-04.png) Hemos marcado también el store porque sabemos nuestra vista interactúa con esta sección del código. Si analizamos el archivo de cobertura asociado a este veremos lo siguiente: ![Imagen que muestra falta de cobertura en store](images/07-testing-frontend-05.png) Resolveremos esto en el siguiente caso ##### Caso 2: Al invocar a la acción getProducts al inicio de la vista NO se crea la lista de productos si el servidor responde con error Resultado esperado ``` No se muestran productos en la lista cuando la llamada al servidor responde con error ``` ```javascript it('Shows an empty list of products when the server response failed', async () => { const wrapper = mount(App,{ localVue, vuetify, store, router }) const errorMessage = 'Database Error in Server' axios.get.mockRejectedValue(new Error(errorMessage)) router.push( { name: 'Products' } ) await flushPromises() expect(wrapper.findAll('[data-cy=product-item]')).toHaveLength(0) expect(store.state.products).toEqual([]) }) ``` Ejecutamos las pruebas y veremos como hemos logrado cubrir todo el código como muestra la siguiente imagen: ![Imagen que muestra cobertura total en store](images/07-testing-frontend-06.png) #### Refactorización del Store Con esto ya tenemos una capa de cobertura o caracterización completa del código que nos permite implementar la refactorización con mayor confianza. En el caso del framework Vue con Vuex es clásico que el `store` es la primera fuente de *code smells* y tenemos una oportunidad de extraer la llamada al servidor en un servicio independiente. Para esto creamos el directorio `services` dentro de `src` y ahora crearemos un archivo llamado `product.service.js` con el siguiente contenido: **frontend/src/services/product.service.js** ```javascript import axios from 'axios' import { Auth } from '@/firebase' const productsURL = 'api/products' export default { async getProducts() { try { const token = await Auth.currentUser?.getIdToken(true) const headers = { Authorization: `Bearer ${token}` } const response = await axios.get(productsURL, { headers }) return response.data } catch (error) { throw new Error('Productos momentáneamente no disponibles') } } } ``` Y en el `store` quedaría así: ```javascript import Vue from 'vue' import Vuex from 'vuex' import productService from '@/services/product.service' Vue.use(Vuex) export default new Vuex.Store({ state: { products: [] }, mutations: { SET_PRODUCTS (store, products) { store.products = products } }, actions: { async getProducts (actionContext) { const { commit } = actionContext try { const products = await productService.getProducts() commit('SET_PRODUCTS', products) } catch (error) { console.error(error.message) } } } }) ``` Ahora volvemos a ejecutar las pruebas y veremos que siguen pasando y que aún mantenemos la cobertura como muestra la siguien imagen: ![Imagen que muestra cobertura total en store](images/07-testing-frontend-07.png) #### Nueva funcionalidad a través de la metodología TDD Escribiremos una nueva funcionalidad para nuestra aplicación. Antes de comenzar haremos una simulación de como se generaría la necesidad de programar algo nuevo en una aplicación si estuvieramos en el caso de una aplicación en la que hay un equipo multidisciplinario involucrado comenzando desde quienes solicitan el cambio hasta como lo hace el programador para describir lo que tiene que hacer y aprovecharemos esto para aplicar la metodolodía TDD: Desarrollo guiado por pruebas **Descripción de la solución de alto nivel** > Crear una alerta centralizada para toda la aplicación que debe mostrar información tanto de éxito como de error manteniendo el estilo visual actual El texto anterior surge de una coordinación entre personas del área de UI, UX, Desarrolladores y roles de negocio en una empresa y que termina en manos de los programadores que debemos ser capaces de implementar estos requerimientos a partir de nuestro conocimientos en la tecnología que está escrita nuestra aplicación. Cuando nos enfrentamos al desafío de implementar esta funcionalidad gracias a nuestro conocimiento en programación, conocimiento del Framework Vue y entendiendo como funciona el patrón de manejo de estados de Vuex, podríamos refinar más el requerimiento ahora en términos técnicos **Descripción técnica** >Lo que haremos será escribir un componente que nos permita mostrar una alerta central que se activará a partir de una propiedad que configuraremos en el store. Para mostrar la alerta de forma central la agregaremos al componente App.vue que se conectará al estado y mostrará o no la alerta en función de si está la alerta o no asignada. El valor del estado lo llamaremos `alert` y su valor por defecto será `null`. Para poder asignar una alerta en el estado expondremos una acción llamada setAlert para estos fines. > En cuanto a la UI utilizaremos el componente `` que trae Vuetify y modelaremos la alerta como un objeto que tenga las propiedades `message` y `type`. Si bien podemos tener una estrategia en mente y entender los conceptos de arquitectura del framework, tener ideas por sobre como resolverlo y probar todo esto directamente en la aplicación, lo que haremos será modificar nuestras pruebas para hacerlas fallar debido a que consultaremos sobre cosas que aún no están programadas y relacionadas a esta funcionalidad. ##### Modo TDD Lo primero será agregar un nuevo script al archivo `frontend/package.json` en la sección correspondiente de la siguiente forma ```javascript \"tdd\": \"npm run test:unit -- --watchAll\" ``` Ahora ejecutamos el comando `npm run tdd` y veremos algo como en la siguiente imagen: ![Imagen que muestra modo tdd de jest](images/07-testing-frontend-08.png) Vemos que ahora la terminal está esperando que se hagan cambios ya sea en las pruebas o en el código fuente. #### Implementación de la alerta cuando falla autenticación en vista Login Comenzaremos por modificar las pruebas que ya habíamos escrito y así hacerlas fallar. Agregaremos una nueva prueba para la vista Login **frontend/tests/unit/Login.spec.js** ```javascript it('Login failed shows global alert', async () => { const wrapper = mount(App, { localVue, vuetify, store, router }) const errorMessage = 'Invalid user' Auth.signInWithEmailAndPassword.mockRejectedValue(new Error(errorMessage)) wrapper.find('[data-cy=username]').setValue('sebastian@boolean.cl') wrapper.find('[data-cy=password]').setValue('academiaboolean') wrapper.find('[data-cy=login-btn]').trigger('click') await flushPromises() const expectedMessage = 'Error al hacer autenticación' expect(wrapper.find('[role=alert]').text()).toEqual(expectedMessage) expect(store.state.alert).toEqual({ message: expectedMessage, type: 'error' }) }) ``` Al actualizarse las pruebas veremos un error como muestra la siguiente imagen: ![Imagen que muestra error en la terminal](images/07-testing-frontend-09.png) Esto ocurre porque en la vista Login no capturamos las excepciones cuando ocurre un error en la función `Auth.signInWithEmailAndPassword`. Vamos a modificar esta vista en el archivo `frontend/src/views/Login.vue` reemplazando la función `login` por lo siguiente: ```javascript async login () { if (this.validate()) { try { await Auth.signInWithEmailAndPassword(this.email, this.password) this.$router.push({ name: 'Products' }) } catch (error) { } } } ``` Ahora al recargarse las pruebas veremos que el error ha cambiado a lo que muestra la siguiente imagen: ![Imagen que muestra error en prueba](images/07-testing-frontend-10.png) Como vimos en unos de los capítulos anteriores, lo que deberíamos hacer es escribir el código más simple posible que que sea capaz se hacer pasar la prueba y luego refactorizar. En este caso como la prueba está fallando agregaremos en la sección `template` el código más simple posible que logre resolver esta prueba: **frontend/src/views/Login.vue** ```html Error al hacer autenticación ... ``` Ahora al recargarse las pruebas vemos que el error ha cambiado: ![Imagen que muestra error en prueba](images/07-testing-frontend-11.png) Y tal como lo hicimos en el caso anterior escribiremos el código más simple posible para pasar esta prueba. esto sería modificar el store en la propiedad `state` con el siguiente código: **frontend/src/store/index.js** ```javascript ... export default new Vuex.Store({ state: { products: [], alert: { message: 'Error al hacer autenticación', type: 'error' } }, ... }) ``` Con este último cambio al recargarse las pruebas vemos que están pasando todas. ##### Refactorización Ahora haremos algunos cambios para que nuestro código sea diseñado como habíamos descrito en la definición técnica. Primero vamos a reemplazar completamente la sección `script` para que quede de la siguiente manera: ```html ``` Si bien las pruebas siguen pasando podemos ver un mensaje de error que dice lo siguiente > console.error node_modules/vuex/dist/vuex.common.js:499 [vuex] unknown action type: setAlert Esto nos está diciendo que estamos tratando de mapear una acción que no existe. Para esto iremos al archivo `frontend/src/store/index.js` y lo reemplazaremos completamente con lo siguiente: ```javascript import Vue from 'vue' import Vuex from 'vuex' import productService from '@/services/product.service' Vue.use(Vuex) export default new Vuex.Store({ state: { products: [], alert: null }, mutations: { SET_PRODUCTS (store, products) { store.products = products }, SET_ALERT (store, alert) { store.alert = alert } }, actions: { async getProducts (actionContext) { const { commit } = actionContext try { const products = await productService.getProducts() commit('SET_PRODUCTS', products) } catch(error) { console.error(error.message) } }, setAlert (actionContext, alert) { const { commit } = actionContext commit('SET_ALERT', alert) } } }) ``` Vemos que al recargarse las pruebas estas siguen pasando. Ahora modificaremos el archivo `src/App.vue` para agregar la alerta global. Y lo reemplazamos por lo siguiente: ```html {{ alert.message }} ``` Una buena oportunidad de separación de responsabilidades sería extraer la alerta a su propio componente y mediante `props` pasar las propiedades reactivas desde el componente `App.vue` al `AppAlert.vue` que crearemos ahora. Para eso creamos el componente `src/components/AppAlert.vue` con el siguiente contenido: ```javascript {{ message }} ``` Ahora con los cambios necesarios en el `App.vue`, quedaría de la siguiente forma: ```javascript ``` Ahora quitaremos el código HTML que agregamos a la vista Login en la sección `template` y veremos que nuestras pruebas continúan pasando a pesar de toda la refactorización que hemos hecho. #### Implementación de la alerta cuando falla el servidor en vista Products Ahora modificaremos la prueba que escribimos para el caso que el servidor falla agregando dos nuevas sentencias `expect` a la prueba ya escrita. Reemplazamos por el siguiente código ```javascript it('Shows an empty list of products when the server response failed', async () => { const wrapper = mount(App,{ localVue, vuetify, store, router }) const errorMessage = 'Database Error in Server' axios.get.mockRejectedValue(new Error(errorMessage)) router.push({ name: 'Products' }) await flushPromises() const expectedMessage = 'Productos momentáneamente no disponibles' expect(wrapper.findAll('[data-cy=product-item]')).toHaveLength(0) expect(store.state.products).toEqual([]) expect(wrapper.find('[role=alert]').text()).toEqual(expectedMessage) }) ``` ![Imagen que muestra error en prueba](images/07-testing-frontend-12.png) Esta vez el código más simple posible para resolver esta prueba no es agregar el HTML de forma estática, porque ya hemos construido nuestra alerta global. Lo único que nos falta es agregar esta alerta cuando detectamos que el servidor al momento de obtener los productos falle. Modificaremos el archivo `frontend/src/store/index.js` en la función `getProducts` para que quede como muestra el siguiente código: ``` javascript ... async getProducts (actionContext) { const { commit } = actionContext try { const products = await productService.getProducts() commit('SET_PRODUCTS', products) } catch(error) { commit('SET_ALERT', { message: error.message, type: 'error' }) } }, ... ``` Vemos que la prueba sigue fallando. Esto es porque para mantener cada una de las pruebas aisladas antes de cada prueba estamos creando un estado inicial para el store y actualmente no incluye el valor `alert`. Iremos a modificar el bloque `beforeEach` y lo reemplazaremos por lo siguiente: ```javascript ... beforeEach(() => { localVue = createLocalVue() vuetify = new Vuetify() store.replaceState({ products: [], alert: null }) axios.get.mockReset() router.push('/') }) ... ``` Luego de hacer este cambio las pruebas se recargarán y podemos ver como están pasando todas una vez más. ![Después del refactor y tdd](images/07-testing-frontend-13.png) #### Probar la aplicación con servidor y frontend corriendo Ahora probaremos la aplicación manualmente corriendo el comando `npm run serve` y en otra ventana corriendo `npm run dev` en Frontend y Backend respectivamente. Como en la siguiente imagen: ![corriedo dos terminales](images/07-testing-frontend-14.png) Y podemos ver cómo en la UI tenemos la alerta funcionando: ![corriedo dos terminales](images/07-testing-frontend-15.png) Momento de un nuevo commit. Agrega lo siguiente desde la raíz del proyecto ```bash git add . git commit -m \"refactor(frontend-refactor): Se agregó set de pruebas de caracterización en el Frontend y luego un refactor para dividir responsabilidades. Además se trabajo alerta global con TDD\" ``` | ⬅️ Refactorización utilizando pruebas de software en Backend | Flujo de desarrollo del proyecto ➡️ | . ",
    "url": "/docs/07-testing-frontend.html",
    "relUrl": "/docs/07-testing-frontend.html"
  },"11": {
    "doc": "Automatización en desarrollo",
    "title": "Automatización en desarrollo",
    "content": "# Flujo de desarrollo del proyecto En el capítulo 3 creamos el monorepo con las partes Frontend y Backend que van a conformar nuestra plataforma pero no configuramos herramientas para el manejo global del proyecto. Implementaremos una forma de revisión de la plataforma para que podamos estandarizar tareas. En esta oportunidad vamos a configurar un script `pre-commit` y de `pre-push` que nos ayuden a mantener prácticas estandarizadas y nos ayuden con la calidad de la plataforma en su totalidad de forma asegurarnos que cada vez que se quiera agregar código al repositorio central, este mantenga su calidad. Nuestro proyecto en la raíz debería verse como en el siguiente esquema: ```bash . ├── backend ├── fixtures └── frontend .gitignore ``` En la raíz del proyecto vamos a ejecutar el siguiente comando: ```bash npm init -f ``` Esto nos creará un archivo como el que se muestra a continuación. ```javascript { \"name\": \"\", \"version\": \"1.0.0\", \"description\": \"\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } ``` Notar que no usaremos la propiedad `main`, por lo que la eliminamos del archivo. Instalaremos los paquetes necesarios con el siguiente comando: ```bash npm install husky npm-run-all ``` Ya tenemos los paquetes necesarios para poder correr scripts asociados a las acciones de git, en este caso `Husky` que es la herramienta que nos ayudará a hacer esto y `npm-run-all` que ejecutará las tareas para el `frontend` y `backend` en simultáneo. Como necesitamos estandarizar las tareas de calidad de código, nos está faltando algo: Necesitamos configurar el linter en Backend con el mismo estándar configurado por Vue para el Frontend. #### Configurar linter en el backend Nos aseguramos de navegar hacia la carpeta `backend` y en su interior ejecutamos el siguiente comando: ```bash npm install --save-dev eslint ``` Ahora modificaremos la sección `scripts` del archivo `backend/package.json` y vamos a exponer el comando `eslint` como se muestra en el siguiente trozo de código: ```javascript \"scripts\": { \"start\": \"nodemon src/server.js\", \"test\": \"jest --runInBand --coverage\", \"eslint\": \"eslint\", \"jest\": \"jest\", \"sequelize\": \"sequelize\" }, ``` Ahora vamos a inicializar Eslint corriendo el siguiente comando: ```bash npm run eslint -- --init ``` Se nos harán una serie de pregunta. Nos aseguraremos de contestarlas con las respuestas que muestra la siguiente imagen: ![Imagen que muestra respuesta a eslint --init](images/08-dev-workflow-05.png) El archivo generado por Eslint debería haber quedado de la siguiente forma: **backend/.eslintrc** ```javascript module.exports = { \"env\": { \"commonjs\": true, \"es2021\": true, \"node\": true }, \"extends\": \"eslint:recommended\", \"parserOptions\": { \"ecmaVersion\": 12 }, \"rules\": { } }; ``` Ahora agregaremos un nuevo script que será el encargado de ejecutar el linter para este proyecto. Volvemos a la sección `script` del archivo `backend/package.json` y debería verse de la siguiente forma: ```javascript \"scripts\": { \"start\": \"nodemon src/server.js\", \"test\": \"jest --runInBand --coverage\", \"lint\": \"eslint .\", \"eslint\": \"eslint\", \"jest\": \"jest\", \"sequelize\": \"sequelize\" }, ``` Ahora podremos ejecutar el siguiente comando desde la raíz del directorio backend: ```bash npm run lint ``` Al ejecutar el comando podremos ver todos los errores asociados al estándar que estamos siguiendo con Eslint, pero también veremos otros errores que están relacionados al Framework para pruebas que estamos usando: Jest. Estos errores se ven como se muestra en la siguiente imagen: ![Imagen que muestra errores de jest en linter](images/08-dev-workflow-06.png) Esto sucede porque el estándar por defecto que instalamos con Eslint no viene preparado para ver los archivos de Jest. Para esto instalaremos un plugin de Eslint con el siguiente comando ejecutado en la raíz del directorio `backend`: ```bash npm i --save-dev eslint-plugin-jest ``` y reemplazamos el contenido del archivo `backend/.eslintsrc` con el siguiente contenido: ```javascript module.exports = { \"env\": { \"commonjs\": true, \"es2021\": true, \"node\": true, \"jest/globals\": true }, \"extends\": \"eslint:recommended\", \"plugins\": [ \"jest\" ], \"parserOptions\": { \"ecmaVersion\": 12 }, \"rules\": { } }; ``` Con esta configuración ya somos capaces de corregir los errores que nos indique Eslint sin problemas corriendo el comando `npm run lint`. Una vez que solucionemos todo los problemas y guardemos los archivos que hemos debido modificar para pasar el linter del lado `backend`, iremos a la carpeta `frontend` y estando en la raíz de este directorio ejecutaremos: ```bash npm run lint ``` Ahora revisamos si es que existen archivos que tengan problemas. De ser así solucionamos los problemas y guardamos los archivos. #### Scripts de pre-commit y pre-push para el proyecto Volveremos a la raíz del proyecto e iremos al archivo `package.json` y modificaremos la sección scripts para que quede de la siguiente manera: ```javascript \"scripts\": { \"frontend-test:unit\": \"cd frontend && npm run test:unit\", \"frontend-lint\": \"cd frontend && npm run lint\", \"backend-lint\": \"cd backend && npm run lint\", \"backend-test\": \"cd backend && npm test\", \"pre-commit\": \"npm-run-all frontend-lint backend-lint\", \"pre-push\": \"npm-run-all frontend-test:unit backend-test\", \"husky\": \"husky\" }, ``` Podemos probar estos scripts primero corriendo los comandos ```bash npm run pre-commit ``` y luego ```bash npm run pre-push ``` Deberíamos a estas alturas tener todos los linter tanto de Frontend como Backend pasando, así como las pruebas unitarias. Nos queda un último paso que sería que estos scripts se activen cada vez que hacemos commit o push de nuestro código. #### Instalar husky ```bash npm run husky install ``` Veras que se configuro una nueva carpeta en la raíz llamada `.husky` Ahora ejecutaremos lo siguiente: ```bash npm run husky add .husky/pre-commit \"npm run pre-commit\" npm run husky add .husky/pre-push \"npm run pre-push\" ``` ahora veremos que dentro del directorio llamado `.husky` hay 2 nuevos archivos. Si revisamos su interior deberíamos ver lo siguiente: **.husky/pre-commit** ```bash #!/bin/sh . \"$(dirname \"$0\")/_/husky.sh\" npm run pre-commit ``` **.husky/pre-push** ```bash #!/bin/sh . \"$(dirname \"$0\")/_/husky.sh\" npm run pre-push ``` Ahora podemos probar que todo esta funcionando. Primero haremos un commit y veremos como es que se corren los linters de los proyectos Frontend y Backend. ```bash git add . git commit -m \"chore(dev-scripts): se agregaron scripts de pre-commit y pre-push para asegurar la calidad de la plataforma\" ``` Veremos como al hacer esto se corre el script `pre-commit`. Si todo salió bien el commit debería hacerse sin problemas. - CONFIGURAR TU REMOTO al final ```bash git push origin main ``` veremos como corren las pruebas antes de que se haga la subida del código a tu repositorio remoto. Ya estamos preparados para subir a producción nuestro proyecto en el siguiente capítulo. | ⬅️ Refactorización utilizando pruebas de software en Frontend | Salida a producción utilizando Github Actions y Heroku ➡️ | . ",
    "url": "/docs/08-development-workflow-husky.html",
    "relUrl": "/docs/08-development-workflow-husky.html"
  },"12": {
    "doc": "Deploy automatizado",
    "title": "Deploy automatizado",
    "content": "# Salida a producción utilizando Github Actions y Heroku Ha sido un largo camino en el cuál hemos construido nuestra plataforma, integrado prácticas comunes de la comunidad Javascript, prácticas relacionadas a la agilidad de Software y varias técnicas de Ingeniería para mejorar nuestro código como el uso de tecnologías en las partes Frontend y Backend. Todo esto fue con el objetivo de poder poner a disposición de los usuarios nuestra plataforma de trueques. Pero hay una pregunta que quien haya seguido estos capítulos puede estar haciendose: > ¿Es acaso un buen momento para salir a producción y disponibilizar la plataforma a los usuarios? - La respuesta es sí. - Pero si solamente tenemos un método de Autenticación y una página de lista de productos. - OK. podemos salir a producción pero no mostrarle aún a los usuarios está página. - Pero es necesario estandarizar desde una etapa temprana el procedimiento de subida a producción. Para ello hay una serie de preguntas técnicas que debemos plantearnos. Veremos si nuestra plataforma cumple al menos con los requerimiento básicos para esta etapa: - ¿Cúal será el método por el cuál disponibilizaremos el Frontend para los usuarios de la plataforma? - ¿Qué método de puesta en producción en servidores en la nube utilizaremos? - ¿Qué tipo base de datos y servicio en la nube para almacenar datos utilizaremos? - ¿Que requisitos debe cumplir el código fuente para salir a producción desde este punto en adelante? Iremos respondiendo a cada una de estas pregunta e implementaremos lo necesario para lograr solucionar lo necesario para salir a producción sin problemas. #### ¿Cúal será el método por el cuál disponibilizaremos el Frontend para los usuarios de la plataforma? En esta oportunidad utilizaremos el enfoque de WEB SERVER + API en el mismo servidor NodeJS. Esto quiere decir que debemos incluir una carpeta en el servidor que contendrá en resultado del proyecto Frontend, esto es, un archivo index.html con los archivos Javascript y CSS, así como los recursos como imágenes, íconos, etc que queramos incluir. De esta forma las peticiones hechas por la parte Frontend hacia el Backend utilizarán el mismo dominio. La siguiente imagen muestra un diagrama que intenta explicar esta estrategia: ![Imagen que muestra la estrategia de puesta en producción con NodeJS](images/09-deployment-postgres-01.png) Para logra esto haremos 2 pasos: 1. Generar un proyecto Frontend listo para poner en producción 2. Agregar una carpeta pública en el proyecto Backend y el código necesario para exponerla a través de Express. ##### Generar un proyecto Frontend listo para poner en producción Para lograr esto ingresaremos a la carpeta `frontend` a través de la terminal y correremos el siguiente comando: ```bash npm run build ``` Deberíamos ver algo como lo que muestra la siguiente imagen: ![Imagen que muestra salida para producción de Vue](images/09-deployment-postgres-02.png) Veremos aparecer una carpeta `dist` en la raíz del directorio `frontend` por lo cuál si accedemos a ella veremos los archivos generados por Vue además de un archivo `index.html` y `favicon.ico`. **backend/src/app.js** ```javascript const express = require('express') const authMiddleware = require('./middleware/auth') const routes = require('./routes') const staticFolder = `${__dirname}/public` const app = express() app.use(express.static(staticFolder)) app.use('/api', authMiddleware) app.use('/api', routes) app.get('*', (request, response) => { return response.sendFile(`${staticFolder}/index.html`) }) module.exports = app ``` - copiar todo el contenido de dist a public - correr `npm run dev` en backend - Agregar al gitignore ```bash backend/src/public ``` - agregar al gitignore `backend/public` y explicar porque #### ¿Qué método de puesta en producción en servidores en la nube utilizaremos? - heroku crear cuenta - heroku crear app intefaz - agregar tarea `start` y sección `engines` **backend/package.json** ```javascript { \"name\": \"backend\", \"version\": \"1.0.0\", \"description\": \"\", \"engines\": { \"node\": \"12.x\" }, \"scripts\": { \"start\": \"node src/server.js\", \"dev\": \"nodemon src/server.js\", \"test\": \"jest --runInBand --coverage\", \"eslint\": \"eslint\", \"lint\": \" eslint .\", \"jest\": \"jest\", \"sequelize\": \"sequelize\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"express\": \"^4.17.1\", \"firebase-admin\": \"^9.6.0\", \"sequelize\": \"^6.6.2\" }, \"devDependencies\": { \"eslint\": \"^7.24.0\", \"eslint-plugin-jest\": \"^24.3.6\", \"jest\": \"^26.6.3\", \"jest-cli\": \"^26.6.3\", \"nodemon\": \"^2.0.7\", \"sequelize-cli\": \"^6.2.0\", \"sqlite3\": \"^5.0.2\", \"supertest\": \"^6.1.3\" } } ``` nos basta la tarea `start` para que heroku reconozca que este será el comando de inicialización. Puedes revisar sobre esta información en la documentación oficial de Heroku a través de [este enlace](https://devcenter.heroku.com/articles/nodejs-support#default-web-process-type) Es también importante configurar la sección `engines` para confifgurar bajo que versión de NodeJS correrá nuestra aplicación. Más detalles en el siguiente [enlace](https://devcenter.heroku.com/articles/nodejs-support#specifying-a-node-js-version) #### ¿Que requisitos debe cumplir el código fuente para salir a producción desde este punto en adelante? - github actions y variable de ambiente para deployment y seguridad en settings/secrets HEROKU_APP_NAME HEROKU_OWNER_EMAIL HEROKU_API_KEY - crear carpeta `.github` en la raíz. dentro otra carpeta llamada `worflows` y ahi dentro un archivo llamado `pipeline.yml` como muestra el siguiente esquema: ``` └─ .github └─ worflows pipeline.yml └─ .husky └─ backend └─ fixtures └─ frontend .gitignore package-lock.json package.json ``` **.github/workflows/pipeline.yml** ```yaml name: Node.js CI on: push: branches: - main jobs: build: runs-on: ubuntu-latest container: image: node:12 steps: - name: Checkout code uses: actions/checkout@v2 - name: Build Deploy Artifact run: | STATIC_FOLDER=backend/src/public cd ./frontend npm install npm run build cd .. mkdir -p $STATIC_FOLDER cp -R ./frontend/dist/. $STATIC_FOLDER ls -R -lha $STATIC_FOLDER - name: Archive production artifact uses: actions/upload-artifact@v2 with: name: platform-artifact path: | backend !backend/tests !backend/.eslintrc.js !backend/jest.config.js !backend/nodemon.json deploy: runs-on: ubuntu-latest needs: build env: HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }} HEROKU_OWNER_EMAIL: ${{ secrets.HEROKU_OWNER_EMAIL }} HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }} steps: - name: Download production artifact uses: actions/download-artifact@v2 with: name: platform-artifact path: backend - name: Setup Heroku Credentials run: | cat > ~/.netrc > .gitignore git add . git commit -m \"deploy: server artifact deployment from github actions\" git push -f heroku main ``` - Pull request, code review y agilidad etc - push y mirar todo el proceso de puesta en producción con la interfaz de Github Actions FALLA! DEBEMOS INCLUIR SERVICE-ACCOUNT crear archivo `.profile` la información de porque creamos este archivo está en el siguiente [enlace](https://devcenter.heroku.com/articles/dynos#the-profile-file) **backend/.profile** ``` OUTPUT_PATH=\"$(pwd)/firebase-service-account.json\" curl -X GET \\ -o $OUTPUT_PATH \\ $SERVICE_ACCOUNT_FILE_URL export GOOGLE_APPLICATION_CREDENTIALS=$OUTPUT_PATH ``` - Interfaz de firebase foto sacar URL - Ir a config vars de Heroku y crear SERVICE_ACCOUNT_FILE_URL. Ahora deberían haber 2: DATABASE_URL y SERVICE_ACCOUNT_FILE_URL. Además mencionar la varianble PORT que lo puedes ver más en detalle en el siguiente [enlace](https://devcenter.heroku.com/articles/dynos#local-environment-variables) Ahora somos capaces de generar el archivo de cuenta de servicio de manera segura a través de la variable GOOGLE_APPLICATION_CREDENTIALS OTRA VEZ FALLA! ESTA VEZ PORQUE SEQUELIZE NO RECONOCE LA CONFIGURACIÓN PARA PRODUCCIÓN #### ¿Qué tipo base de datos y servicio en la nube para almacenar datos utilizaremos? - instalar postgres como dependencia del backend en `backend` en la raíz: ```bash npm i pg ``` - heroku agregar ADDON Heroku Postgres interfaz - revisar config vars y veremos DATABASE_URL que usaremos más adelante - configurar sequelize para producción usando ```javascript \"production\": { \"use_env_variable\": \"DATABASE_URL\", \"dialect\": \"postgres\", \"dialectOptions\": { \"ssl\":{ \"rejectUnauthorized\": false } }, \"logging\": false } ``` Ahora hacemos push, esperamos el deploy! autenticamos y vemos error 500 en la DB \"no existe tabla productos\" NOS FALTAN LAS MIGRACIONES agregar scripts `db:migrate` y `heroku-postbuild` a `backend/package.json` ```javascript \"db:migrate\": \"npm run sequelize db:migrate\", \"heroku-postbuild\": \"npm run db:migrate -- --env=production\" ``` Utilizamos `heroku-postbuild` ya que en esta etapa podemos utilizar las dependencias de desarrollo ya que antes de la publicación Heroku elimina las dependencias de desarrollo. para saber más sobre los scripts que puede correr heroku utilizando las config vars seteadas en al interfaz puede ver más detalle en el siguiente [enlace](https://devcenter.heroku.com/articles/nodejs-support#heroku-specific-build-steps) hacer push y listo AHORA SI FUNCIONA!!!! pero la tabla productos está vacia. Mostrar foto array vacio en el response del endpoint de productos #### Cargar datos en la base de datos y ver los productos #### Agregar un usuario real a la aplicación para terminar | ⬅️ Flujo de desarrollo del proyecto | Volver al Índice del curso ➡️ | . ",
    "url": "/docs/09-deployment-postgres.html",
    "relUrl": "/docs/09-deployment-postgres.html"
  },"13": {
    "doc": "Inicio",
    "title": "Inicio",
    "content": "![Logo de Boolean Academia](https://res.cloudinary.com/boolean-spa/image/upload/v1591158800/logo_vayedu.svg) # Proyecto de Integración Curso Javascript Full Stack: Plataforma de trueque > PENDING: Tener un prólogo que explique el contexto del proyecto con el material del curso y cómo está enfocado en aplicar los conocimientos del curso más la metodología de desarrollo ágil en un proyecto digital utilizando javascript en todo el stack. Mencionar que haremos todo el scaffolding para trabajar de forma profesionarl y que será el alumno quien debe luego de completar esto, construir su propia aplicación resolviendo Historias de Usuario de alto nivel y ellos deben darle la especificidad. Vamos a construir la base de una plataforma de trueques utilizando Javascript. Seguiremos la metodología BDD para implementar una historia de usuario. Utilizaremos el framework *VueJS* para construir una vista de ingreso (*login*) que nos permitirá acceder a un catálogo de instrumentos musicales disponibles para trueques. La autenticación será soportada por la plataforma Firebase y la aplicación será publicada utilizando la plataforma Heroku, en la cual montaremos un servidor que construiremos utilizando NodeJS y la librería Express. Manos a la obra! Índice: - [Creando un proyecto usando CLI y framework UI](docs/01-vue-cli-install.md) - [Implementando historias de usuario con BDD](docs/02-bdd-with-cypress.md) - [Reorganización del proyecto como fullstack Javascript](docs/03-monorepo-backend.md) - [Autenticar en el Frontend y validar en el Backend](docs/04-firebase-sdk-backend.md) - [Agregando base de datos en entorno de desarrollo](docs/05-database-sequelize.md) - [Refactorización utilizando pruebas de software en Backend](docs/06-testing-backend.md) - [Refactorización utilizando pruebas de software en Frontend](docs/07-testing-frontend.md) - [Automatización de tareas para el desarrollo](docs/08-development-workflow-husky.md) - [Salida a producción utilizando Github Actions y Heroku](docs/09-deployment-postgres.md) ",
    "url": "/",
    "relUrl": "/"
  }
}
